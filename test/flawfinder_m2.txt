Flawfinder version 1.27, (C) 2001-2004 David A. Wheeler.
Number of dangerous functions in C/C++ ruleset: 160
./curl-83.40.2/curl/docs/examples/asiohiper.cpp:77:  [4] (shell) system:
  This causes a new program to execute and is difficult to use safely.
  try using a library call that implements the same functionality if
  available. 
static void timer_cb(const boost::system::error_code & error, GlobalInfo *g);
./curl-83.40.2/curl/docs/examples/asiohiper.cpp:96:  [4] (shell) system:
  This causes a new program to execute and is difficult to use safely.
  try using a library call that implements the same functionality if
  available. 
    boost::system::error_code error; /*success*/
./curl-83.40.2/curl/docs/examples/asiohiper.cpp:198:  [4] (shell) system:
  This causes a new program to execute and is difficult to use safely.
  try using a library call that implements the same functionality if
  available. 
static void timer_cb(const boost::system::error_code & error, GlobalInfo *g)
./curl-83.40.2/curl/docs/examples/asiohiper.cpp:358:  [4] (shell) system:
  This causes a new program to execute and is difficult to use safely.
  try using a library call that implements the same functionality if
  available. 
    boost::system::error_code ec;
./curl-83.40.2/curl/docs/examples/cookie_interface.c:88:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
#define snprintf _snprintf
./curl-83.40.2/curl/docs/examples/cookie_interface.c:88:  [4] (format) _snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
#define snprintf _snprintf
./curl-83.40.2/curl/docs/examples/curlx.c:407:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(serverurl,"https://%s",hostporturl);
./curl-83.40.2/curl/docs/examples/curlx.c:445:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
  sprintf(contenttype,"Content-type: %s",mimetype);
./curl-83.40.2/curl/docs/examples/evhiperfifo.c:72:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
#define DPRINT(x...) printf(x)
./curl-83.40.2/curl/docs/examples/htmltidy.c:59:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
        printf(tidyAttrName(attr));
./curl-83.40.2/curl/docs/examples/rtsp.c:147:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(sdp_filename, "%s.sdp", s);
./curl-83.40.2/curl/docs/examples/rtsp.c:163:  [4] (buffer) sscanf:
  The scanf() family's %s operation, without a limit specification,
  permits buffer overflows. Specify a limit to %s, or use a different input
  function. 
      sscanf(s, " a = control: %s", control);
./curl-83.40.2/curl/docs/examples/rtsp.c:231:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(uri, "%s", url);
./curl-83.40.2/curl/docs/examples/rtsp.c:241:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(uri, "%s/%s", url, control);
./curl-83.40.2/curl/docs/examples/rtsp.c:245:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(uri, "%s/", url);
./curl-83.40.2/curl/docs/examples/synctime.c:151:  [4] (buffer) sscanf:
  The scanf() family's %s operation, without a limit specification,
  permits buffer overflows. Specify a limit to %s, or use a different input
  function. 
        RetVal = sscanf ((char *)(ptr), "Date: %s %hu %s %hu %hu:%hu:%hu",
./curl-83.40.2/curl/include/curl/mprintf.h:48:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef printf
./curl-83.40.2/curl/include/curl/mprintf.h:49:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef fprintf
./curl-83.40.2/curl/include/curl/mprintf.h:50:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# undef sprintf
./curl-83.40.2/curl/include/curl/mprintf.h:51:  [4] (buffer) vsprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# undef vsprintf
./curl-83.40.2/curl/include/curl/mprintf.h:52:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# undef snprintf
./curl-83.40.2/curl/include/curl/mprintf.h:53:  [4] (format) vprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef vprintf
./curl-83.40.2/curl/include/curl/mprintf.h:54:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef vfprintf
./curl-83.40.2/curl/include/curl/mprintf.h:55:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# undef vsnprintf
./curl-83.40.2/curl/include/curl/mprintf.h:58:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define printf curl_mprintf
./curl-83.40.2/curl/include/curl/mprintf.h:59:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define fprintf curl_mfprintf
./curl-83.40.2/curl/include/curl/mprintf.h:60:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# define sprintf curl_msprintf
./curl-83.40.2/curl/include/curl/mprintf.h:61:  [4] (buffer) vsprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# define vsprintf curl_mvsprintf
./curl-83.40.2/curl/include/curl/mprintf.h:62:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# define snprintf curl_msnprintf
./curl-83.40.2/curl/include/curl/mprintf.h:63:  [4] (format) vprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define vprintf curl_mvprintf
./curl-83.40.2/curl/include/curl/mprintf.h:64:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define vfprintf curl_mvfprintf
./curl-83.40.2/curl/include/curl/mprintf.h:65:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# define vsnprintf curl_mvsnprintf
./curl-83.40.2/curl/lib/curl_ntlm_core.c:694:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  snprintf((char *)ptr + NTLM_HMAC_MD5_LEN, NTLMv2_BLOB_LEN,
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:382:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  snprintf((char *)ntlmbuf, NTLM_BUFSIZE,
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:652:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  size = snprintf((char *)ntlmbuf, NTLM_BUFSIZE,
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:179:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
  if(access(ntlm_auth, X_OK) != 0) {
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:224:  [4] (shell) execl:
  This causes a new program to execute and is difficult to use safely.
  try using a library call that implements the same functionality if
  available. 
      execl(ntlm_auth, ntlm_auth,
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:231:  [4] (shell) execl:
  This causes a new program to execute and is difficult to use safely.
  try using a library call that implements the same functionality if
  available. 
      execl(ntlm_auth, ntlm_auth,
./curl-83.40.2/curl/lib/curl_printf.h:32:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef printf
./curl-83.40.2/curl/lib/curl_printf.h:33:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef fprintf
./curl-83.40.2/curl/lib/curl_printf.h:34:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# undef snprintf
./curl-83.40.2/curl/lib/curl_printf.h:35:  [4] (format) vprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef vprintf
./curl-83.40.2/curl/lib/curl_printf.h:36:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef vfprintf
./curl-83.40.2/curl/lib/curl_printf.h:37:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# undef vsnprintf
./curl-83.40.2/curl/lib/curl_printf.h:40:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define printf curl_mprintf
./curl-83.40.2/curl/lib/curl_printf.h:41:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define fprintf curl_mfprintf
./curl-83.40.2/curl/lib/curl_printf.h:42:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# define snprintf curl_msnprintf
./curl-83.40.2/curl/lib/curl_printf.h:43:  [4] (format) vprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define vprintf curl_mvprintf
./curl-83.40.2/curl/lib/curl_printf.h:44:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define vfprintf curl_mvfprintf
./curl-83.40.2/curl/lib/curl_printf.h:45:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# define vsnprintf curl_mvsnprintf
./curl-83.40.2/curl/lib/curl_printf.h:51:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# undef sprintf
./curl-83.40.2/curl/lib/curl_printf.h:52:  [4] (buffer) vsprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# undef vsprintf
./curl-83.40.2/curl/lib/curl_printf.h:53:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# define sprintf sprintf_was_used
./curl-83.40.2/curl/lib/curl_printf.h:54:  [4] (buffer) vsprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# define vsprintf vsprintf_was_used
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:1173:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy((char *) message + sizeof(outdata), user_name);
./curl-83.40.2/curl/lib/curlx.h:94:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef printf
./curl-83.40.2/curl/lib/curlx.h:95:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef fprintf
./curl-83.40.2/curl/lib/curlx.h:96:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# undef sprintf
./curl-83.40.2/curl/lib/curlx.h:97:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# undef snprintf
./curl-83.40.2/curl/lib/curlx.h:98:  [4] (format) vprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef vprintf
./curl-83.40.2/curl/lib/curlx.h:99:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# undef vfprintf
./curl-83.40.2/curl/lib/curlx.h:100:  [4] (buffer) vsprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# undef vsprintf
./curl-83.40.2/curl/lib/curlx.h:101:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# undef vsnprintf
./curl-83.40.2/curl/lib/curlx.h:105:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define printf curlx_mprintf
./curl-83.40.2/curl/lib/curlx.h:106:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define fprintf curlx_mfprintf
./curl-83.40.2/curl/lib/curlx.h:107:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# define sprintf curlx_msprintf
./curl-83.40.2/curl/lib/curlx.h:108:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# define snprintf curlx_msnprintf
./curl-83.40.2/curl/lib/curlx.h:109:  [4] (format) vprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define vprintf curlx_mvprintf
./curl-83.40.2/curl/lib/curlx.h:110:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
# define vfprintf curlx_mvfprintf
./curl-83.40.2/curl/lib/curlx.h:111:  [4] (buffer) vsprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
# define vsprintf curlx_mvsprintf
./curl-83.40.2/curl/lib/curlx.h:112:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
# define vsnprintf curlx_mvsnprintf
./curl-83.40.2/curl/lib/formdata.c:878:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  vsnprintf(s, sizeof(s), fmt, ap);
./curl-83.40.2/curl/lib/ftp.c:1042:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
        strcpy(addr, string_ftpport);
./curl-83.40.2/curl/lib/ftp.c:1052:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
      strcpy(addr, string_ftpport);
./curl-83.40.2/curl/lib/ftp.c:4091:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
./curl-83.40.2/curl/lib/inet_ntop.c:70:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(dst, tmp);
./curl-83.40.2/curl/lib/inet_ntop.c:167:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(dst, tmp);
./curl-83.40.2/curl/lib/ldap.c:707:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
  vfprintf (stderr, fmt, args);
./curl-83.40.2/curl/lib/memdebug.c:477:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  nchars = vsnprintf(buf, LOGLINE_BUFSIZE, format, ap);
./curl-83.40.2/curl/lib/mprintf.c:919:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        (sprintf)(work, formatbuf, p->data.dnum);
./curl-83.40.2/curl/lib/progress.c:43:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
    snprintf(r, 9, "%2" CURL_FORMAT_CURL_OFF_T ":%02" CURL_FORMAT_CURL_OFF_T
./curl-83.40.2/curl/lib/progress.c:71:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
    snprintf(max5, 6, "%5" CURL_FORMAT_CURL_OFF_T, bytes);
./curl-83.40.2/curl/lib/security.c:122:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
./curl-83.40.2/curl/lib/security.c:402:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(buffer, buf);
./curl-83.40.2/curl/lib/sendf.c:132:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
    vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
./curl-83.40.2/curl/lib/sendf.c:149:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);
./curl-83.40.2/curl/lib/smb.c:121:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(p, (str)); \
./curl-83.40.2/curl/lib/smb.c:126:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(p, (str)); \
./curl-83.40.2/curl/lib/smb.c:525:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(msg.bytes, req->path);
./curl-83.40.2/curl/lib/smb.h:167:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
  unsigned int access;
./curl-83.40.2/curl/lib/socks.c:232:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
        strcpy((char*)socksreq + packetsize, hostname);
./curl-83.40.2/curl/lib/socks_gssapi.c:67:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
          strcpy(buf+len, (char*) status_string.value);
./curl-83.40.2/curl/lib/socks_gssapi.c:88:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
          strcpy(buf+len, (char*) status_string.value);
./curl-83.40.2/curl/lib/ssh.c:820:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
            else if(access(sshc->rsa, R_OK) != 0) {
./curl-83.40.2/curl/lib/ssh.c:825:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
              else if(access(sshc->rsa, R_OK) != 0) {
./curl-83.40.2/curl/lib/ssh.c:833:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
            if(sshc->rsa && access(sshc->rsa, R_OK) != 0) {
./curl-83.40.2/curl/lib/ssh.c:836:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
              if(sshc->rsa && access(sshc->rsa, R_OK) != 0) {
./curl-83.40.2/curl/lib/tftp.c:410:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(buf, option);
./curl-83.40.2/curl/lib/tftp.c:499:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
      snprintf(buf, sizeof(buf), "%" CURL_FORMAT_CURL_OFF_T,
./curl-83.40.2/curl/lib/version.c:70:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(ptr, LIBCURL_NAME "/" LIBCURL_VERSION);
./curl-83.40.2/curl/lib/vtls/gskit.c:354:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
          strcpy(ciphers[i].ptr, ctp->gsktoken);
./curl-83.40.2/curl/lib/vtls/gskit.c:404:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
      strcpy(ciphers[CURL_GSKPROTO_SSLV3].ptr,
./curl-83.40.2/curl/packages/OS400/os400sys.c:1129:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(cp, cp2);
./curl-83.40.2/curl/packages/OS400/os400sys.c:1161:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(cp, cp2);
./curl-83.40.2/curl/packages/OS400/os400sys.c:1193:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(cp, cp2);
./curl-83.40.2/curl/src/tool_cb_prg.c:94:  [4] (format) fprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
    fprintf(bar->out, format, line, percent);
./curl-83.40.2/curl/src/tool_dirhie.c:127:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
          strcpy(dirbuildup, tempdir);
./curl-83.40.2/curl/src/tool_dirhie.c:131:  [4] (race) access:
  This usually indicates a security flaw.  If an attacker can change
  anything along the path between the call to access() and the file's actual
  use (e.g., by moving files), the attacker can exploit the race
  condition. Set up the correct permissions (e.g., using setuid()) and try to
  open the file directly. 
      if(access(dirbuildup, F_OK) == -1) {
./curl-83.40.2/curl/src/tool_doswin.c:111:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
  strcpy(new_name, msdosify(file_name));
./curl-83.40.2/curl/src/tool_doswin.c:230:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
    strcpy(file_name, fname);
./curl-83.40.2/curl/src/tool_getparam.c:1187:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
              strcpy(n, enc);
./curl-83.40.2/curl/src/tool_help.c:305:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
  printf(CURL_ID "%s\n", curl_version());
./curl-83.40.2/curl/src/tool_main.c:103:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
    strcpy(fname, env);
./curl-83.40.2/curl/src/tool_msgs.c:50:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
./curl-83.40.2/curl/src/tool_msgs.c:91:  [4] (format) vfprintf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
    vfprintf(errors, fmt, ap);
./curl-83.40.2/curl/src/tool_paramhlp.c:79:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
      strcpy(string+stringlen, buffer);
./curl-83.40.2/curl/src/tool_parsecfg.c:355:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
      strcpy(&line[linelen], buf);
./curl-83.40.2/curl/src/tool_setopt.c:532:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
    snprintf(buf, sizeof(buf),
./curl-83.40.2/curl/tests/libtest/first.c:93:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
    strcpy(fname, env);
./curl-83.40.2/curl/tests/libtest/lib1502.c:54:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
  sprintf(redirect, "google.com:%s:%s", libtest_arg2, libtest_arg3);
./curl-83.40.2/curl/tests/libtest/lib1506.c:49:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(dnsentry, "server%d.example.com:%s:%s", i + 1, port, address);
./curl-83.40.2/curl/tests/libtest/lib1506.c:72:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(target_url, "http://server%d.example.com:%s/path/1506%04i",
./curl-83.40.2/curl/tests/libtest/lib1510.c:47:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(dnsentry, "server%d.example.com:%s:%s", i + 1, port, address);
./curl-83.40.2/curl/tests/libtest/lib1510.c:76:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(target_url, "http://server%d.example.com:%s/path/1510%04i",
./curl-83.40.2/curl/tests/libtest/lib1512.c:52:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
  sprintf(dnsentry, "server.example.curl:%s:%s", port, address);
./curl-83.40.2/curl/tests/libtest/lib1512.c:61:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(target_url, "http://server.example.curl:%s/path/1512%04i",
./curl-83.40.2/curl/tests/libtest/lib1900.c:66:  [4] (buffer) fscanf:
  The scanf() family's %s operation, without a limit specification,
  permits buffer overflows. Specify a limit to %s, or use a different input
  function. 
    if(fscanf(f, "%d %s\n", &filetime, buf)) {
./curl-83.40.2/curl/tests/libtest/lib1900.c:73:  [4] (buffer) fscanf:
  The scanf() family's %s operation, without a limit specification,
  permits buffer overflows. Specify a limit to %s, or use a different input
  function. 
    if(fscanf(f, "blacklist_site %s\n", buf)) {
./curl-83.40.2/curl/tests/libtest/lib1900.c:116:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
  sprintf(urlbuf, "%s%s", base_url, urlstring[handlenum]);
./curl-83.40.2/curl/tests/libtest/lib518.c:60:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(msgbuff, "%s", msg);
./curl-83.40.2/curl/tests/libtest/lib518.c:62:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(msgbuff, "%s, errno %d, %s", msg, err, strerror(err));
./curl-83.40.2/curl/tests/libtest/lib518.c:136:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, rl.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:144:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, rl.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:202:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff, fmt, rl.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:210:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff, fmt, rl.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:237:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff2, fmt, rl.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:238:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:239:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "fds needed %s > system limit %s",
./curl-83.40.2/curl/tests/libtest/lib518.c:261:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:289:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff1, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:290:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "unable to allocate an array for %s "
./curl-83.40.2/curl/tests/libtest/lib518.c:300:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
  sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:320:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
  sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:327:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "opening of %s failed", DEV_NULL);
./curl-83.40.2/curl/tests/libtest/lib518.c:348:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:349:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(strbuff, "dup() attempt %s failed", strbuff1);
./curl-83.40.2/curl/tests/libtest/lib518.c:352:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:353:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(strbuff, "fds system limit seems close to %s", strbuff1);
./curl-83.40.2/curl/tests/libtest/lib518.c:358:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff2, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:359:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib518.c:360:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(strbuff, "fds needed %s > system limit %s",
./curl-83.40.2/curl/tests/libtest/lib518.c:378:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
  sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:433:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff1, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib518.c:434:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "stdio fopen() fails with %s fds open()",
./curl-83.40.2/curl/tests/libtest/lib530.c:56:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(target_url, "%s%04i", URL, i + 1);
./curl-83.40.2/curl/tests/libtest/lib537.c:61:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(msgbuff, "%s", msg);
./curl-83.40.2/curl/tests/libtest/lib537.c:63:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(msgbuff, "%s, errno %d, %s", msg, err, strerror(err));
./curl-83.40.2/curl/tests/libtest/lib537.c:137:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, rl.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib537.c:145:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, rl.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:197:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff, fmt, rl.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib537.c:205:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff, fmt, rl.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:235:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:278:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff1, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:279:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "unable to allocate an array for %s "
./curl-83.40.2/curl/tests/libtest/lib537.c:290:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:314:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
  sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:321:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "opening of %s failed", DEV_NULL);
./curl-83.40.2/curl/tests/libtest/lib537.c:342:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib537.c:343:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(strbuff, "dup() attempt %s failed", strbuff1);
./curl-83.40.2/curl/tests/libtest/lib537.c:346:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib537.c:347:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(strbuff, "fds system limit seems close to %s", strbuff1);
./curl-83.40.2/curl/tests/libtest/lib537.c:353:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff1, fmt, num_open.rlim_cur);
./curl-83.40.2/curl/tests/libtest/lib537.c:354:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(strbuff, "closing %s file descriptors", strbuff1);
./curl-83.40.2/curl/tests/libtest/lib537.c:364:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:381:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
  sprintf(strbuff, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:436:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
    sprintf(strbuff1, fmt, num_open.rlim_max);
./curl-83.40.2/curl/tests/libtest/lib537.c:437:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(strbuff, "stdio fopen() fails with %s fds open()",
./curl-83.40.2/curl/tests/libtest/lib539.c:67:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
   newURL = strcat(strcpy(newURL, URL), "./");
./curl-83.40.2/curl/tests/libtest/lib540.c:203:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
  sprintf(buffer, "Host: %s", HOST);
./curl-83.40.2/curl/tests/libtest/lib547.c:57:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
    strcpy(ptr, UPLOADTHIS);
./curl-83.40.2/curl/tests/libtest/lib555.c:56:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
    strcpy(ptr, UPLOADTHIS);
./curl-83.40.2/curl/tests/libtest/libauthretry.c:41:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
  sprintf(full_url, "%s%04d", url, seq);
./curl-83.40.2/curl/tests/libtest/libntlmconnect.c:148:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(full_url, "%s0200", url);
./curl-83.40.2/curl/tests/libtest/libntlmconnect.c:151:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(full_url, "%s0100", url);
./curl-83.40.2/curl/tests/server/fake_ntlm.c:79:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
    sprintf(&outbuf[0], "%s", NOTHING_STR);
./curl-83.40.2/curl/tests/server/fake_ntlm.c:101:  [4] (format) sprintf:
  Potential format string problem. Make format string constant. 
      sprintf(&outbuf[o], HEX_FMT_STR, inbuf[i]);
./curl-83.40.2/curl/tests/server/getpart.c:47:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be
  exploited. Use a constant for the format specification. 
#define show(x) printf x
./curl-83.40.2/curl/tests/server/getpart.c:401:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
        strcpy(couter, ptag);
./curl-83.40.2/curl/tests/server/getpart.c:407:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
        strcpy(cmain, ptag);
./curl-83.40.2/curl/tests/server/getpart.c:413:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). 
        strcpy(csub, ptag);
./curl-83.40.2/curl/tests/server/rtspd.c:378:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(logbuf, "Got request: %s %s %s/%d.%d",
./curl-83.40.2/curl/tests/server/rtspd.c:381:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(logbuf, "Got a *HUGE* request %s/%d.%d",
./curl-83.40.2/curl/tests/server/rtspd.c:532:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(logbuf, "Received a CONNECT %s HTTP/%d.%d request",
./curl-83.40.2/curl/tests/server/rtspd.c:942:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(weare, "HTTP/1.1 200 OK\r\nContent-Length: %zu\r\n\r\n%s",
./curl-83.40.2/curl/tests/server/sockfilt.c:1040:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf((char *)buffer, "%s/%hu\n", ipv_inuse, port);
./curl-83.40.2/curl/tests/server/sws.c:494:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(logbuf, "Got request: %s %s HTTP/%d.%d",
./curl-83.40.2/curl/tests/server/sws.c:551:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(logbuf, "Received a CONNECT %s HTTP/%d.%d request",
./curl-83.40.2/curl/tests/server/sws.c:1082:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(weare, "%s", msgbuf);
./curl-83.40.2/curl/tests/server/sws.c:1084:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
        sprintf(weare, "HTTP/1.1 200 OK\r\nContent-Length: %zu\r\n\r\n%s",
./curl-83.40.2/curl/tests/server/sws.c:1106:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(partbuf, "%s%ld", section, req->partno);
./curl-83.40.2/curl/tests/server/sws.c:1108:  [4] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. 
      sprintf(partbuf, "%s", section);
./curl-83.40.2/curl/tests/server/util.c:119:  [4] (format) vsnprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  vsnprintf(buffer, sizeof(buffer), msg, ap);
./curl-83.40.2/curl/tests/server/util.c:190:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be
  exploited, and note that sprintf variations do not always \0-terminate. Use a
  constant for the format specification. 
  snprintf(filename, sizeof(filename), TEST_DATA_PATH, path, testno);
./curl-83.40.2/curl/docs/examples/curlx.c:313:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
        p.pst = getenv(*(++args));
./curl-83.40.2/curl/include/curl/curl.h:1913:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
CURL_EXTERN char *curl_getenv(const char *variable);
./curl-83.40.2/curl/lib/config-dos.h:152:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
#define CURL_CA_BUNDLE  getenv("CURL_CA_BUNDLE")
./curl-83.40.2/curl/lib/curl_gethostname.c:67:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  const char *force_hostname = getenv("CURL_GETHOSTNAME");
./curl-83.40.2/curl/lib/curl_ntlm_core.c:676:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  char *force_timestamp = getenv("CURL_FORCETIME");
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:143:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
    username = getenv("NTLMUSER");
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:145:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
      username = getenv("LOGNAME");
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:147:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
      username = getenv("USER");
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:172:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  ntlm_auth_alloc = curl_getenv("CURL_NTLM_WB_FILE");
./curl-83.40.2/curl/lib/curl_setup.h:642:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
#define CURL_CA_BUNDLE getenv("CURL_CA_BUNDLE")
./curl-83.40.2/curl/lib/curl_sspi.c:115:  [3] (misc) LoadLibrary:
  Ensure that the full path to the library is specified, or current
  directory may be used. Use registry entry or GetWindowsDirectory to find
  library path, if you aren't already. 
      s_hSecDll = LoadLibrary(TEXT("security.dll"));
./curl-83.40.2/curl/lib/curl_sspi.c:117:  [3] (misc) LoadLibrary:
  Ensure that the full path to the library is specified, or current
  directory may be used. Use registry entry or GetWindowsDirectory to find
  library path, if you aren't already. 
      s_hSecDll = LoadLibrary(TEXT("secur32.dll"));
./curl-83.40.2/curl/lib/curl_threads.h:42:  [3] (misc) InitializeCriticalSection:
  Exceptions can be thrown in low-memory situations. Use
  InitializeCriticalSectionAndSpinCount instead. 
#    define Curl_mutex_init(m)   InitializeCriticalSection(m)
./curl-83.40.2/curl/lib/curl_threads.h:46:  [3] (misc) EnterCriticalSection:
  On some versions of Windows, exceptions can be thrown in low-memory
  situations. Use InitializeCriticalSectionAndSpinCount instead. 
#  define Curl_mutex_acquire(m)  EnterCriticalSection(m)
./curl-83.40.2/curl/lib/curlx.h:75:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
#define curlx_getenv curl_getenv
./curl-83.40.2/curl/lib/easy.c:159:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  if(!getenv("CHARSET") && cp > 0) {
./curl-83.40.2/curl/lib/getenv.c:38:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  char *temp = getenv(variable);
./curl-83.40.2/curl/lib/getenv.c:44:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  char *env = getenv(variable);
./curl-83.40.2/curl/lib/getenv.c:50:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
char *curl_getenv(const char *v)
./curl-83.40.2/curl/lib/ldap.c:700:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
    const char *env = getenv("CURL_TRACE");
./curl-83.40.2/curl/lib/netrc.c:74:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
    char *home = curl_getenv("HOME"); /* portable environment reader */
./curl-83.40.2/curl/lib/setup-vms.h:37:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
#define getenv decc_getenv
./curl-83.40.2/curl/lib/setup-vms.h:50:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
#undef getenv
./curl-83.40.2/curl/lib/setup-vms.h:52:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
#define getenv vms_getenv
./curl-83.40.2/curl/lib/ssh.c:809:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
        home = curl_getenv("HOME");
./curl-83.40.2/curl/lib/telnet.c:1337:  [3] (misc) LoadLibrary:
  Ensure that the full path to the library is specified, or current
  directory may be used. Use registry entry or GetWindowsDirectory to find
  library path, if you aren't already. 
  wsock2 = LoadLibrary(TEXT("WS2_32.DLL"));
./curl-83.40.2/curl/lib/url.c:4460:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  no_proxy=curl_getenv("no_proxy");
./curl-83.40.2/curl/lib/url.c:4462:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
    no_proxy=curl_getenv("NO_PROXY");
./curl-83.40.2/curl/lib/url.c:4478:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
    prox=curl_getenv(proxy_env);
./curl-83.40.2/curl/lib/url.c:4495:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
      prox=curl_getenv(proxy_env);
./curl-83.40.2/curl/lib/url.c:4501:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
      proxy = curl_getenv("all_proxy"); /* default proxy to use */
./curl-83.40.2/curl/lib/url.c:4503:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
        proxy=curl_getenv("ALL_PROXY");
./curl-83.40.2/curl/lib/vtls/nss.c:1191:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  cert_dir = getenv("SSL_DIR");
./curl-83.40.2/curl/lib/vtls/vtls.c:191:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  char *force_entropy = getenv("CURL_ENTROPY");
./curl-83.40.2/curl/src/tool_homedir.c:57:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  env = getenv(variable);
./curl-83.40.2/curl/src/tool_main.c:264:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  if(getenv("_IN_NETWARE_BASH_") == NULL)
./curl-83.40.2/curl/src/tool_vms.c:56:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  shell = getenv("SHELL");
./curl-83.40.2/curl/tests/libtest/first.c:87:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  env = curl_getenv("CURL_MEMDEBUG");
./curl-83.40.2/curl/tests/libtest/first.c:101:  [3] (buffer) curl_getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  env = curl_getenv("CURL_MEMLIMIT");
./curl-83.40.2/curl/tests/libtest/sethostname.c:32:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  const char *force_hostname = getenv("CURL_GETHOSTNAME");
./curl-83.40.2/curl/tests/server/fake_ntlm.c:165:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  env = getenv("CURL_NTLM_AUTH_TESTNUM");
./curl-83.40.2/curl/tests/server/fake_ntlm.c:179:  [3] (buffer) getenv:
  Environment variables are untrustable input if they can be set by an
  attacker.  They can have any content and length, and the same variable
  can be set more than once. Check environment variables carefully before
  using them. 
  env = getenv("CURL_NTLM_AUTH_SRCDIR");
./curl-83.40.2/curl/CMake/CurlTests.c:116:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[8192];
./curl-83.40.2/curl/CMake/CurlTests.c:512:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[1024]; /* big enough to play with */
./curl-83.40.2/curl/CMake/CurlTests.c:526:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[1024]; /* big enough to play with */
./curl-83.40.2/curl/docs/examples/anyauthput.c:130:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd = open(file, O_RDONLY) ;
./curl-83.40.2/curl/docs/examples/asiohiper.cpp:74:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error[CURL_ERROR_SIZE];
./curl-83.40.2/curl/docs/examples/asiohiper.cpp:359:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    tcp_socket->open(boost::asio::ip::tcp::v4(), ec);
./curl-83.40.2/curl/docs/examples/cookie_interface.c:67:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char nline[256];
./curl-83.40.2/curl/docs/examples/curlgtk.c:52:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    outfile = fopen("test.curl", "w");
./curl-83.40.2/curl/docs/examples/curlx.c:149:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(tmp, ia5->data, ia5->length);
./curl-83.40.2/curl/docs/examples/evhiperfifo.c:95:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error[CURL_ERROR_SIZE];
./curl-83.40.2/curl/docs/examples/evhiperfifo.c:360:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char s[1024];
./curl-83.40.2/curl/docs/examples/evhiperfifo.c:400:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  sockfd = open(fifo, O_RDWR | O_NONBLOCK, 0);
./curl-83.40.2/curl/docs/examples/fileupload.c:35:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fd = fopen("debugit", "rb"); /* open file to upload */
./curl-83.40.2/curl/docs/examples/fopen.c:117:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&url->buffer[url->buffer_pos], buffer, size);
./curl-83.40.2/curl/docs/examples/fopen.c:243:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  if((file->handle.file=fopen(url,operation)))
./curl-83.40.2/curl/docs/examples/fopen.c:355:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, file->buffer, want);
./curl-83.40.2/curl/docs/examples/fopen.c:403:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, file->buffer, want);
./curl-83.40.2/curl/docs/examples/fopen.c:455:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[256];
./curl-83.40.2/curl/docs/examples/fopen.c:464:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  outf=fopen("fgets.test","w+");
./curl-83.40.2/curl/docs/examples/fopen.c:488:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  outf=fopen("fread.test","w+");
./curl-83.40.2/curl/docs/examples/fopen.c:512:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  outf=fopen("rewind.test","w+");
./curl-83.40.2/curl/docs/examples/ftp-wildcard.c:118:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    data->output = fopen(finfo->filename, "w");
./curl-83.40.2/curl/docs/examples/ftpget.c:43:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    out->stream=fopen(out->filename, "wb");
./curl-83.40.2/curl/docs/examples/ftpgetresp.c:48:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  ftpfile = fopen("ftp-list", "wb"); /* b is binary, needed on win32 */
./curl-83.40.2/curl/docs/examples/ftpgetresp.c:51:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  respfile = fopen("ftp-responses", "wb"); /* b is binary, needed on win32 */
./curl-83.40.2/curl/docs/examples/ftpsget.c:45:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    out->stream=fopen(out->filename, "wb");
./curl-83.40.2/curl/docs/examples/ftpupload.c:89:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd_src = fopen(LOCAL_FILE, "rb");
./curl-83.40.2/curl/docs/examples/ftpuploadresume.c:91:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  f = fopen(localpath, "rb");
./curl-83.40.2/curl/docs/examples/getinmemory.c:51:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&(mem->memory[mem->size]), contents, realsize);
./curl-83.40.2/curl/docs/examples/ghiper.c:84:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error[CURL_ERROR_SIZE];
./curl-83.40.2/curl/docs/examples/ghiper.c:411:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
 socket = open (fifo, O_RDWR | O_NONBLOCK, 0);
./curl-83.40.2/curl/docs/examples/hiperfifo.c:91:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error[CURL_ERROR_SIZE];
./curl-83.40.2/curl/docs/examples/hiperfifo.c:348:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char s[1024];
./curl-83.40.2/curl/docs/examples/hiperfifo.c:385:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  sockfd = open(fifo, O_RDWR | O_NONBLOCK, 0);
./curl-83.40.2/curl/docs/examples/href_extractor.c:42:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    html_parser_char_parse(hsp, ((char *)buffer)[p]);
./curl-83.40.2/curl/docs/examples/href_extractor.c:55:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char tag[1], attr[4], val[128];
./curl-83.40.2/curl/docs/examples/htmltidy.c:81:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char curl_errbuf[CURL_ERROR_SIZE];
./curl-83.40.2/curl/docs/examples/htmltitle.cpp:63:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static char errorBuffer[CURL_ERROR_SIZE];
./curl-83.40.2/curl/docs/examples/http2-download.c:145:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char filename[128];
./curl-83.40.2/curl/docs/examples/http2-download.c:147:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
  sprintf(filename, "dl-%d", num);
./curl-83.40.2/curl/docs/examples/http2-download.c:149:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  out = fopen(filename, "wb");
./curl-83.40.2/curl/docs/examples/http2-download.c:188:  [2] (integer) atoi:
  Unless checked, the resulting number can exceed the expected range. 
  If source untrusted, check both minimum and maximum, even if the input
  had no minus sign (large numbers can roll over into negative number;
  consider saving to an unsigned value if that is intended). 
    num_transfers = atoi(argv[1]);
./curl-83.40.2/curl/docs/examples/http2-upload.c:109:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char timebuf[20];
./curl-83.40.2/curl/docs/examples/http2-upload.c:180:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char url[256];
./curl-83.40.2/curl/docs/examples/http2-upload.c:181:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char filename[128];
./curl-83.40.2/curl/docs/examples/http2-upload.c:185:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
  sprintf(filename, "dl-%d", num);
./curl-83.40.2/curl/docs/examples/http2-upload.c:186:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  out = fopen(filename, "wb");
./curl-83.40.2/curl/docs/examples/http2-upload.c:188:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
  sprintf(url, "https://localhost:8443/upload-%d", num);
./curl-83.40.2/curl/docs/examples/http2-upload.c:194:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  indata[num].in = fopen(upload, "rb");
./curl-83.40.2/curl/docs/examples/http2-upload.c:245:  [2] (integer) atoi:
  Unless checked, the resulting number can exceed the expected range. 
  If source untrusted, check both minimum and maximum, even if the input
  had no minus sign (large numbers can roll over into negative number;
  consider saving to an unsigned value if that is intended). 
    num_transfers = atoi(argv[1]);
./curl-83.40.2/curl/docs/examples/httpput.c:77:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd_src = fopen(file, "rb");
./curl-83.40.2/curl/docs/examples/imap-append.c:68:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/docs/examples/multi-uv.c:79:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char filename[50];
./curl-83.40.2/curl/docs/examples/multi-uv.c:83:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
  sprintf(filename, "%d.download", num);
./curl-83.40.2/curl/docs/examples/multi-uv.c:85:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  file = fopen(filename, "w");
./curl-83.40.2/curl/docs/examples/multithread.c:40:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
const char * const urls[NUMT]= {
./curl-83.40.2/curl/docs/examples/postinmemory.c:45:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&(mem->memory[mem->size]), contents, realsize);
./curl-83.40.2/curl/docs/examples/rtsp.c:86:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  FILE *sdp_fp = fopen(sdp_filename, "wt");
./curl-83.40.2/curl/docs/examples/rtsp.c:143:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
  strcpy(sdp_filename, "video.sdp");
./curl-83.40.2/curl/docs/examples/rtsp.c:159:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  FILE *sdp_fp = fopen(sdp_filename, "rt");
./curl-83.40.2/curl/docs/examples/sendrecv.c:118:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buf[1024];
./curl-83.40.2/curl/docs/examples/sepheaders.c:57:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  headerfile = fopen(headerfilename, "wb");
./curl-83.40.2/curl/docs/examples/sepheaders.c:64:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  bodyfile = fopen(bodyfilename, "wb");
./curl-83.40.2/curl/docs/examples/sftpget.c:48:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    out->stream=fopen(out->filename, "wb");
./curl-83.40.2/curl/docs/examples/simplessl.c:70:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  headerfile = fopen("dumpit", "w");
./curl-83.40.2/curl/docs/examples/smooth-gtk-thread.c:88:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      outfile = fopen(urls[j], "w");
./curl-83.40.2/curl/docs/examples/smtp-mail.c:69:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/docs/examples/smtp-multi.c:70:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/docs/examples/smtp-ssl.c:70:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/docs/examples/smtp-tls.c:70:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/docs/examples/synctime.c:99:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char http_proxy[MAX_STRING1];
./curl-83.40.2/curl/docs/examples/synctime.c:100:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char proxy_user[MAX_STRING1];
./curl-83.40.2/curl/docs/examples/synctime.c:101:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char timeserver[MAX_STRING1];
./curl-83.40.2/curl/docs/examples/synctime.c:104:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
const char DefaultTimeServer[3][MAX_STRING1] =
./curl-83.40.2/curl/docs/examples/synctime.c:135:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char  TmpStr1[26], TmpStr2[26];
./curl-83.40.2/curl/docs/examples/synctime.c:207:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    outfile = fopen(OutFileName, "wb");
./curl-83.40.2/curl/docs/examples/synctime.c:261:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char    timeBuf[61];
./curl-83.40.2/curl/docs/examples/synctime.c:262:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char    tzoneBuf[16];
./curl-83.40.2/curl/docs/examples/url2file.c:63:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  pagefile = fopen(pagefilename, "wb");
./curl-83.40.2/curl/docs/examples/xmlstream.c:76:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&(mem->memory[mem->size]), s, len);
./curl-83.40.2/curl/include/curl/curlrules.h:141:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
typedef char
./curl-83.40.2/curl/include/curl/curlrules.h:151:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
typedef char
./curl-83.40.2/curl/include/curl/curlrules.h:161:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
typedef char
./curl-83.40.2/curl/include/curl/curlrules.h:171:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
typedef char
./curl-83.40.2/curl/include/curl/curlrules.h:181:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
typedef char
./curl-83.40.2/curl/lib/asyn-ares.c:670:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char a6[INET6_ADDRSTRLEN];
./curl-83.40.2/curl/lib/asyn-thread.c:271:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char service[12];
./curl-83.40.2/curl/lib/asyn-thread.c:598:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char sbuf[12];
./curl-83.40.2/curl/lib/base64.c:177:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char ibuf[3];
./curl-83.40.2/curl/lib/base64.c:178:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char obuf[4];
./curl-83.40.2/curl/lib/connect.c:269:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char myhost[256] = "";
./curl-83.40.2/curl/lib/connect.c:393:  [2] (integer) atoi:
  Unless checked, the resulting number can exceed the expected range. 
  If source untrusted, check both minimum and maximum, even if the input
  had no minus sign (large numbers can roll over into negative number;
  consider saving to an unsigned value if that is intended). 
            si6->sin6_scope_id = atoi(scope_ptr);
./curl-83.40.2/curl/lib/connect.c:601:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(conn->data->info.conn_primary_ip, conn->primary_ip, MAX_IPADR_LEN);
./curl-83.40.2/curl/lib/connect.c:602:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(conn->data->info.conn_local_ip, conn->local_ip, MAX_IPADR_LEN);
./curl-83.40.2/curl/lib/connect.c:698:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(conn->ip_addr_str, conn->primary_ip, MAX_IPADR_LEN);
./curl-83.40.2/curl/lib/connect.c:824:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
        char ipaddress[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/connect.c:999:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char ipaddress[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/connect.c:1323:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&addr->sa_addr, ai->ai_addr, addr->addrlen);
./curl-83.40.2/curl/lib/content_encoding.c:357:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(z->next_in, k->str, z->avail_in);
./curl-83.40.2/curl/lib/content_encoding.c:383:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(z->next_in + z->avail_in - nread, k->str, nread);
./curl-83.40.2/curl/lib/cookie.c:375:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char name[MAX_NAME];
./curl-83.40.2/curl/lib/cookie.c:619:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(co->path, path, pathlen);
./curl-83.40.2/curl/lib/cookie.c:917:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    fp = file?fopen(file, FOPEN_READTEXT):NULL;
./curl-83.40.2/curl/lib/cookie.c:1051:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
            memcpy(newco, co, sizeof(struct Cookie));
./curl-83.40.2/curl/lib/cookie.c:1265:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    out = fopen(dumphere, FOPEN_WRITETEXT);
./curl-83.40.2/curl/lib/curl_addrinfo.c:172:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ca->ai_addr, ai->ai_addr, ss_size);
./curl-83.40.2/curl/lib/curl_addrinfo.c:333:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&addr->sin_addr, curr, sizeof(struct in_addr));
./curl-83.40.2/curl/lib/curl_addrinfo.c:342:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&addr6->sin6_addr, curr, sizeof(struct in6_addr));
./curl-83.40.2/curl/lib/curl_addrinfo.c:369:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char *h_addr_list[2];
./curl-83.40.2/curl/lib/curl_addrinfo.c:416:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(addrentry, inaddr, sizeof(struct in_addr));
./curl-83.40.2/curl/lib/curl_addrinfo.c:422:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(addrentry, inaddr, sizeof(struct in6_addr));
./curl-83.40.2/curl/lib/curl_addrinfo.c:506:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(sa_un->sun_path, path, path_len + 1); /* copy NUL byte */
./curl-83.40.2/curl/lib/curl_fnmatch.c:72:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char keyword[KEYLEN] = { 0 };
./curl-83.40.2/curl/lib/curl_fnmatch.c:314:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char charset[CURLFNM_CHSET_SIZE] = { 0 };
./curl-83.40.2/curl/lib/curl_gssapi.c:97:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[1024];
./curl-83.40.2/curl/lib/curl_multibyte.c:43:  [2] (buffer) MultiByteToWideChar:
  Requires maximum length in CHARACTERS, not bytes. 
    int str_w_len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS,
./curl-83.40.2/curl/lib/curl_multibyte.c:48:  [2] (buffer) MultiByteToWideChar:
  Requires maximum length in CHARACTERS, not bytes. 
        if(MultiByteToWideChar(CP_UTF8, 0, str_utf8, -1, str_w,
./curl-83.40.2/curl/lib/curl_ntlm_core.c:164:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char key[8];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:184:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char key[8];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:208:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char key[8];                                /* expanded 64 bit key */
./curl-83.40.2/curl/lib/curl_ntlm_core.c:266:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char key[8];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:289:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char key[8];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:318:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char key[8];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:347:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(out, in, 8);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:424:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char pw[14];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:549:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy (ntbuffer, gcry_md_read (MD4pw, 0), MD4_DIGEST_LENGTH);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:666:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char hmac_output[NTLM_HMAC_MD5_LEN];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:700:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr + 32, challenge_client, 8);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:701:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr + 44, ntlm->target_info, ntlm->target_info_len);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:704:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr + 8, &ntlm->nonce[0], 8);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:713:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr, hmac_output, NTLM_HMAC_MD5_LEN);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:741:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char data[16];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:742:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char hmac_output[16];
./curl-83.40.2/curl/lib/curl_ntlm_core.c:745:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&data[0], challenge_server, 8);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:746:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&data[8], challenge_client, 8);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:753:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(lmresp, hmac_output, 16);
./curl-83.40.2/curl/lib/curl_ntlm_core.c:754:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(lmresp+16, challenge_client, 8);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:188:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(ntlm->target_info, &buffer[target_info_offset], target_info_len);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:289:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ntlm->nonce, &type2[24], 8);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:363:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char ntlmbuf[NTLM_BUFSIZE];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:489:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char ntlmbuf[NTLM_BUFSIZE];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:491:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char lmresp[24]; /* fixed-size */
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:495:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char ntresp[24]; /* fixed-size */
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:500:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char host[HOSTNAME_MAX + 1] = "";
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:537:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char ntbuffer[0x18];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:539:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char ntlmv2hash[0x18];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:575:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char ntbuffer[0x18];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:576:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char tmp[0x18];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:577:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char md5sum[MD5_DIGEST_LENGTH];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:585:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(lmresp, entropy, 8);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:591:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(tmp, &ntlm->nonce[0], 8);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:592:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(tmp + 8, entropy, 8);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:612:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char ntbuffer[0x18];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:614:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char lmbuffer[0x18];
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:740:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ntlmbuf[size], lmresp, 0x18);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:752:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ntlmbuf[size], ptr_ntresp, ntresplen);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:783:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ntlmbuf[size], domain, domlen);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:791:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ntlmbuf[size], user, userlen);
./curl-83.40.2/curl/lib/curl_ntlm_msgs.c:799:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ntlmbuf[size], host, hostlen);
./curl-83.40.2/curl/lib/curl_ntlm_wb.c:124:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char pwbuf[1024];
./curl-83.40.2/curl/lib/curl_sasl.c:320:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(plainauth, userp, ulen);
./curl-83.40.2/curl/lib/curl_sasl.c:322:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(plainauth + ulen + 1, userp, ulen);
./curl-83.40.2/curl/lib/curl_sasl.c:324:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);
./curl-83.40.2/curl/lib/curl_sasl.c:453:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char digest[MD5_DIGEST_LEN];
./curl-83.40.2/curl/lib/curl_sasl.c:593:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char digest[MD5_DIGEST_LEN];
./curl-83.40.2/curl/lib/curl_sasl.c:594:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
./curl-83.40.2/curl/lib/curl_sasl.c:595:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
./curl-83.40.2/curl/lib/curl_sasl.c:596:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
./curl-83.40.2/curl/lib/curl_sasl.c:597:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char nonce[64];
./curl-83.40.2/curl/lib/curl_sasl.c:598:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char realm[128];
./curl-83.40.2/curl/lib/curl_sasl.c:599:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char algorithm[64];
./curl-83.40.2/curl/lib/curl_sasl.c:600:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char qop_options[64];
./curl-83.40.2/curl/lib/curl_sasl.c:602:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char cnonce[33];
./curl-83.40.2/curl/lib/curl_sasl.c:773:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char value[DIGEST_MAX_VALUE_LENGTH];
./curl-83.40.2/curl/lib/curl_sasl.c:774:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char content[DIGEST_MAX_CONTENT_LENGTH];
./curl-83.40.2/curl/lib/curl_sasl.c:906:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
./curl-83.40.2/curl/lib/curl_sasl.c:907:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char request_digest[33];
./curl-83.40.2/curl/lib/curl_sasl.c:909:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
./curl-83.40.2/curl/lib/curl_sasl.c:910:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
./curl-83.40.2/curl/lib/curl_sasl.c:911:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char cnoncebuf[33];
./curl-83.40.2/curl/lib/curl_sasl_gssapi.c:290:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&indata, output_token.value, 4);
./curl-83.40.2/curl/lib/curl_sasl_gssapi.c:328:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(message, &outdata, sizeof(outdata));
./curl-83.40.2/curl/lib/curl_sasl_gssapi.c:329:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(message + sizeof(outdata), username_token.value,
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:299:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char value[DIGEST_MAX_VALUE_LENGTH];
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:300:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char content[DIGEST_MAX_CONTENT_LENGTH];
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:521:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(resp, resp_buf.pvBuffer, resp_buf.cbBuffer);
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:995:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(krb5->context, &context, sizeof(context));
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:1122:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&indata, input_buf[1].pvBuffer, 4);
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:1172:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(message, &outdata, sizeof(outdata));
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:1223:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(appdata, wrap_buf[0].pvBuffer, wrap_buf[0].cbBuffer);
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:1225:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(appdata + offset, wrap_buf[1].pvBuffer, wrap_buf[1].cbBuffer);
./curl-83.40.2/curl/lib/curl_sasl_sspi.c:1227:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(appdata + offset, wrap_buf[2].pvBuffer, wrap_buf[2].cbBuffer);
./curl-83.40.2/curl/lib/dotdot.c:165:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(outptr, &input[oindex], qlen+1); /* include the ending zero byte */
./curl-83.40.2/curl/lib/easy.c:156:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[60];
./curl-83.40.2/curl/lib/escape.c:163:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char hexstr[3];
./curl-83.40.2/curl/lib/file.c:76:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
#  define open_readonly(p,f) open((p),(f),(0))
./curl-83.40.2/curl/lib/file.c:78:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
#  define open_readonly(p,f) open((p),(f))
./curl-83.40.2/curl/lib/file.c:337:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fd = open(file->path, mode, conn->data->set.new_file_perms);
./curl-83.40.2/curl/lib/formdata.c:754:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[8192];
./curl-83.40.2/curl/lib/formdata.c:759:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  file = fopen(name, "r"); /* VMS */
./curl-83.40.2/curl/lib/formdata.c:829:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(newform->line, line, length);
./curl-83.40.2/curl/lib/formdata.c:875:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char s[4096];
./curl-83.40.2/curl/lib/formdata.c:927:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buffer[8192];
./curl-83.40.2/curl/lib/formdata.c:1259:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
          stdin:fopen(file->contents, "rb"); /* binary read for win32  */
./curl-83.40.2/curl/lib/formdata.c:1281:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
            char buffer[512];
./curl-83.40.2/curl/lib/formdata.c:1367:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
# define fopen_read fopen
./curl-83.40.2/curl/lib/formdata.c:1388:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    return fopen(file, "r"); /* VMS */
./curl-83.40.2/curl/lib/formdata.c:1391:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    return fopen(file, "r", "rfm=stmlf", "ctx=stm");
./curl-83.40.2/curl/lib/formdata.c:1468:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(buffer + gotsize , form->data->line + form->sent,
./curl-83.40.2/curl/lib/formdata.c:1476:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buffer+gotsize,
./curl-83.40.2/curl/lib/ftp.c:974:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char myhost[256] = "";
./curl-83.40.2/curl/lib/ftp.c:979:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char hbuf[NI_MAXHOST];
./curl-83.40.2/curl/lib/ftp.c:985:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char tmp[1024];
./curl-83.40.2/curl/lib/ftp.c:1162:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(sa, ai->ai_addr, ai->ai_addrlen);
./curl-83.40.2/curl/lib/ftp.c:1945:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char separator[4];
./curl-83.40.2/curl/lib/ftp.c:2403:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buffer[24]= { "Accept-ranges: bytes\r\n" };
./curl-83.40.2/curl/lib/ftp.c:3560:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[256];
./curl-83.40.2/curl/lib/ftp.c:4081:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char s[SBUF_SIZE];
./curl-83.40.2/curl/lib/ftp.c:4094:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
  strcpy(&s[write_len], "\r\n"); /* append a trailing CRLF */
./curl-83.40.2/curl/lib/getenv.c:37:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char env[MAX_PATH]; /* MAX_PATH is from windef.h */
./curl-83.40.2/curl/lib/hash.c:101:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(dupkey, key, key_len);
./curl-83.40.2/curl/lib/hostip.c:776:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char hostname[256];
./curl-83.40.2/curl/lib/hostip.c:777:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char address[256];
./curl-83.40.2/curl/lib/hostip4.c:140:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char sbuf[12];
./curl-83.40.2/curl/lib/hostip6.c:137:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char  buf[INET6_ADDRSTRLEN];
./curl-83.40.2/curl/lib/hostip6.c:168:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char sbuf[12];
./curl-83.40.2/curl/lib/hostip6.c:170:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char addrbuf[128];
./curl-83.40.2/curl/lib/http.c:281:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(value, start, len);
./curl-83.40.2/curl/lib/http.c:1012:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buffer, http->postdata, (size_t)http->postsize);
./curl-83.40.2/curl/lib/http.c:1032:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(buffer, http->postdata, fullsize);
./curl-83.40.2/curl/lib/http.c:1126:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(conn->data->state.uploadbuffer, ptr, sendsize);
./curl-83.40.2/curl/lib/http.c:1283:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&in->buffer[in->size_used], inptr, size);
./curl-83.40.2/curl/lib/http.c:1759:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char ftp_typecode[sizeof("/;type=?")] = "";
./curl-83.40.2/curl/lib/http.c:2062:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(newurl, url, ptr - url);
./curl-83.40.2/curl/lib/http.c:2064:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(newurl + (ptr - url), conn->host.name, newlen);
./curl-83.40.2/curl/lib/http.c:2066:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(newurl + newlen + (ptr - url),
./curl-83.40.2/curl/lib/http.c:2879:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(k->hbufp, k->str_start, length);
./curl-83.40.2/curl/lib/http.c:3254:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char scratch[SCRATCHSIZE+1]; /* "HTTP/major.minor 123" */
./curl-83.40.2/curl/lib/http2.c:280:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&stream->mem[stream->memlen],
./curl-83.40.2/curl/lib/http2.c:375:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&stream->mem[stream->memlen], data, nread);
./curl-83.40.2/curl/lib/http2.c:620:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buf, stream->upload_mem, nread);
./curl-83.40.2/curl/lib/http2.c:835:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(mem, stream->header_recvbuf->buffer + stream->nread_header_recvbuf,
./curl-83.40.2/curl/lib/http2.c:861:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(mem, stream->pausedata, nread);
./curl-83.40.2/curl/lib/http2.c:1069:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  nva[0].namelen = (uint16_t)strlen((char *)nva[0].name);
./curl-83.40.2/curl/lib/http2.c:1078:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  nva[1].namelen = (uint16_t)strlen((char *)nva[1].name);
./curl-83.40.2/curl/lib/http2.c:1084:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  nva[2].namelen = (uint16_t)strlen((char *)nva[2].name);
./curl-83.40.2/curl/lib/http2.c:1089:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  nva[2].valuelen = (uint16_t)strlen((char *)nva[2].value);
./curl-83.40.2/curl/lib/http2.c:1103:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      nva[i].namelen = (uint16_t)strlen((char *)nva[i].name);
./curl-83.40.2/curl/lib/http2.c:1309:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(httpc->inbuf, mem, nread);
./curl-83.40.2/curl/lib/http_chunks.h:83:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char hexbuffer[ MAXNUM_SIZE + 1];
./curl-83.40.2/curl/lib/idn_win32.c:74:  [2] (buffer) wchar_t:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    wchar_t punycode[IDN_MAX_LENGTH];
./curl-83.40.2/curl/lib/if2ip.c:139:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
            char scope[12] = "";
./curl-83.40.2/curl/lib/if2ip.c:140:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
            char ipstr[64];
./curl-83.40.2/curl/lib/if2ip.c:199:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[256];
./curl-83.40.2/curl/lib/if2ip.c:230:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(req.ifr_name, interf, len+1);
./curl-83.40.2/curl/lib/if2ip.c:242:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&in, &s->sin_addr, sizeof(in));
./curl-83.40.2/curl/lib/if2ip.h:53:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char ifrn_name[IFNAMSIZ]; /* if name, e.g. "en0" */
./curl-83.40.2/curl/lib/imap.c:1053:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char tmp[20];
./curl-83.40.2/curl/lib/imap.h:77:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char resptag[5];            /* Response tag to wait for */
./curl-83.40.2/curl/lib/inet_ntop.c:53:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char tmp[sizeof "255.255.255.255"];
./curl-83.40.2/curl/lib/inet_ntop.c:87:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char tmp[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
./curl-83.40.2/curl/lib/inet_pton.c:97:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char tmp[INADDRSZ], *tp;
./curl-83.40.2/curl/lib/inet_pton.c:131:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(dst, tmp, INADDRSZ);
./curl-83.40.2/curl/lib/inet_pton.c:154:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char tmp[IN6ADDRSZ], *tp, *endp, *colonp;
./curl-83.40.2/curl/lib/inet_pton.c:229:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(dst, tmp, IN6ADDRSZ);
./curl-83.40.2/curl/lib/krb5.c:94:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(buf, "599 ");
./curl-83.40.2/curl/lib/krb5.c:98:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(buf, dec.value, dec.length);
./curl-83.40.2/curl/lib/krb5.c:142:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(*to, enc.value, enc.length);
./curl-83.40.2/curl/lib/md4.c:57:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char buffer[64];
./curl-83.40.2/curl/lib/md4.c:226:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&ctx->buffer[used], data, size);
./curl-83.40.2/curl/lib/md4.c:230:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ctx->buffer[used], data, available);
./curl-83.40.2/curl/lib/md4.c:241:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ctx->buffer, data, size);
./curl-83.40.2/curl/lib/md5.c:52:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX * ctx)
./curl-83.40.2/curl/lib/md5.c:78:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX * ctx)
./curl-83.40.2/curl/lib/md5.c:80:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(digest, gcry_md_read(*ctx, 0), 16);
./curl-83.40.2/curl/lib/md5.c:120:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *ctx)
./curl-83.40.2/curl/lib/md5.c:152:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *ctx)
./curl-83.40.2/curl/lib/md5.c:222:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char buffer[64];
./curl-83.40.2/curl/lib/md5.c:413:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&ctx->buffer[used], data, size);
./curl-83.40.2/curl/lib/md5.c:417:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&ctx->buffer[used], data, available);
./curl-83.40.2/curl/lib/md5.c:428:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ctx->buffer, data, size);
./curl-83.40.2/curl/lib/memdebug.c:115:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      logfile = fopen(logname, FOPEN_WRITETEXT);
./curl-83.40.2/curl/lib/memdebug.c:236:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(mem, str, len);
./curl-83.40.2/curl/lib/memdebug.c:261:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(mem, str, bsiz);
./curl-83.40.2/curl/lib/memdebug.c:422:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  FILE *res=fopen(file, mode);
./curl-83.40.2/curl/lib/memdebug.h:149:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
#undef fopen
./curl-83.40.2/curl/lib/memdebug.h:150:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
#define fopen(file,mode) curl_fopen(file,mode,__LINE__,__FILE__)
./curl-83.40.2/curl/lib/mprintf.c:576:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char *endpos[MAX_PARAMETERS];
./curl-83.40.2/curl/lib/mprintf.c:579:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char work[BUFFSIZE];
./curl-83.40.2/curl/lib/mprintf.c:866:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
        char formatbuf[32]="%";
./curl-83.40.2/curl/lib/multi.c:2097:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(data->sockets, socks, num*sizeof(curl_socket_t));
./curl-83.40.2/curl/lib/multi.c:2177:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(tv, e->ptr, sizeof(*tv));
./curl-83.40.2/curl/lib/multi.c:2537:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(timedup, stamp, sizeof(*timedup));
./curl-83.40.2/curl/lib/netrc.c:81:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char pwbuf[1024];
./curl-83.40.2/curl/lib/netrc.c:112:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  file = fopen(netrcfile, FOPEN_READTEXT);
./curl-83.40.2/curl/lib/netrc.c:119:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char netrcbuffer[256];
./curl-83.40.2/curl/lib/non-ascii.c:66:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(convbuf, indata, insize);
./curl-83.40.2/curl/lib/openldap.c:194:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char hosturl[1024];
./curl-83.40.2/curl/lib/openldap.c:199:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
  strcpy(hosturl, "ldap");
./curl-83.40.2/curl/lib/parsedate.c:97:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char name[5];
./curl-83.40.2/curl/lib/parsedate.c:354:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buf[32]="";
./curl-83.40.2/curl/lib/parsedate.h:25:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
extern const char * const Curl_wkday[7];
./curl-83.40.2/curl/lib/parsedate.h:26:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
extern const char * const Curl_month[12];
./curl-83.40.2/curl/lib/pingpong.c:297:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(ptr, pp->cache, pp->cache_size);
./curl-83.40.2/curl/lib/pingpong.c:429:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(pp->cache, pp->linestart_resp, pp->cache_size);
./curl-83.40.2/curl/lib/pop3.c:451:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char digest[MD5_DIGEST_LEN];
./curl-83.40.2/curl/lib/pop3.c:452:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char secret[2 * MD5_DIGEST_LEN + 1];
./curl-83.40.2/curl/lib/pop3.c:674:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(pop3c->apoptimestamp, line + i, timestamplen);
./curl-83.40.2/curl/lib/progress.c:36:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
    strcpy(r, "--:--:--");
./curl-83.40.2/curl/lib/progress.c:265:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char max5[6][10];
./curl-83.40.2/curl/lib/progress.c:276:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char time_left[10];
./curl-83.40.2/curl/lib/progress.c:277:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char time_total[10];
./curl-83.40.2/curl/lib/progress.c:278:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char time_spent[10];
./curl-83.40.2/curl/lib/rtsp.c:606:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(rtspc->rtp_buf + rtspc->rtp_bufsize, k->str, *nread);
./curl-83.40.2/curl/lib/rtsp.c:680:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(scratch, rtp, rtp_dataleft);
./curl-83.40.2/curl/lib/rtsp.c:799:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(data->set.str[STRING_RTSP_SESSION_ID], start, end - start);
./curl-83.40.2/curl/lib/security.c:119:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char print_buffer[50];
./curl-83.40.2/curl/lib/security.c:222:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(data, (char*)buf->data + buf->index, len);
./curl-83.40.2/curl/lib/sendf.c:130:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char print_buffer[2048 + 1];
./curl-83.40.2/curl/lib/sendf.c:357:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(dupl, ptr, len);
./curl-83.40.2/curl/lib/sendf.c:409:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(newptr + data->state.tempwritesize, ptr, len);
./curl-83.40.2/curl/lib/sendf.c:570:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(buf, conn->master_buffer + conn->read_pos, bytestocopy);
./curl-83.40.2/curl/lib/sendf.c:594:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buf, conn->master_buffer, nread);
./curl-83.40.2/curl/lib/sendf.c:608:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static const char s_infotype[CURLINFO_END][3] = {
./curl-83.40.2/curl/lib/sendf.c:612:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[BUFSIZE+1];
./curl-83.40.2/curl/lib/sendf.c:624:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buf, ptr, size);
./curl-83.40.2/curl/lib/sendf.c:680:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buffer[160];
./curl-83.40.2/curl/lib/smb.c:349:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy((char *)h->magic, "\xffSMB", 4);
./curl-83.40.2/curl/lib/smb.c:411:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(conn->data->state.uploadbuffer + sizeof(struct smb_header),
./curl-83.40.2/curl/lib/smb.c:429:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char lm_hash[21];
./curl-83.40.2/curl/lib/smb.c:430:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char lm[24];
./curl-83.40.2/curl/lib/smb.c:431:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char nt_hash[21];
./curl-83.40.2/curl/lib/smb.c:432:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char nt[24];
./curl-83.40.2/curl/lib/smb.c:459:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(p, lm, sizeof(lm));
./curl-83.40.2/curl/lib/smb.c:461:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(p, nt, sizeof(nt));
./curl-83.40.2/curl/lib/smb.c:679:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(smbc->challenge, nrsp->bytes, sizeof(smbc->challenge));
./curl-83.40.2/curl/lib/smb.h:37:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char challenge[8];
./curl-83.40.2/curl/lib/smb.h:98:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char magic[4];
./curl-83.40.2/curl/lib/smb.h:104:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char signature[8];
./curl-83.40.2/curl/lib/smb.h:128:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char bytes[1];
./curl-83.40.2/curl/lib/smb.h:148:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char bytes[1024];
./curl-83.40.2/curl/lib/smb.h:157:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char bytes[1024];
./curl-83.40.2/curl/lib/smb.h:180:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char bytes[1024];
./curl-83.40.2/curl/lib/smtp.c:1537:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char localhost[HOSTNAME_MAX + 1];
./curl-83.40.2/curl/lib/smtp.c:1617:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);
./curl-83.40.2/curl/lib/smtp.c:1635:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],
./curl-83.40.2/curl/lib/smtp.c:1647:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);
./curl-83.40.2/curl/lib/sockaddr.h:37:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char cbuf[256];   /* this should be big enough to fit a lot */
./curl-83.40.2/curl/lib/socks.c:117:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char socksreq[SOCKS4REQLEN]; /* room for SOCKS4 request incl. user
./curl-83.40.2/curl/lib/socks.c:172:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buf[64];
./curl-83.40.2/curl/lib/socks.c:210:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq + 8, proxy_name, plen+1);
./curl-83.40.2/curl/lib/socks.c:371:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char socksreq[600]; /* room for large user/pw (255 max each) */
./curl-83.40.2/curl/lib/socks.c:505:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(socksreq + len, proxy_name, proxy_name_len);
./curl-83.40.2/curl/lib/socks.c:509:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(socksreq + len, proxy_password, proxy_password_len);
./curl-83.40.2/curl/lib/socks.c:572:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&socksreq[len], hostname, hostname_len); /* address str w/o NULL */
./curl-83.40.2/curl/lib/socks_gssapi.c:54:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buf[1024];
./curl-83.40.2/curl/lib/socks_gssapi.c:76:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(buf+len, ".\n");
./curl-83.40.2/curl/lib/socks_gssapi.c:122:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char socksreq[4]; /* room for GSS-API exchange header only */
./curl-83.40.2/curl/lib/socks_gssapi.c:139:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(service.value, serviceptr, service.length);
./curl-83.40.2/curl/lib/socks_gssapi.c:195:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(socksreq+2, &us_length, sizeof(short));
./curl-83.40.2/curl/lib/socks_gssapi.c:260:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&us_length, socksreq+2, sizeof(short));
./curl-83.40.2/curl/lib/socks_gssapi.c:319:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(user, gss_send_token.value, gss_send_token.length);
./curl-83.40.2/curl/lib/socks_gssapi.c:375:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq+2, &us_length, sizeof(short));
./curl-83.40.2/curl/lib/socks_gssapi.c:384:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(gss_send_token.value, &gss_enc, 1);
./curl-83.40.2/curl/lib/socks_gssapi.c:400:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq+2, &us_length, sizeof(short));
./curl-83.40.2/curl/lib/socks_gssapi.c:412:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq, &gss_enc, 1);
./curl-83.40.2/curl/lib/socks_gssapi.c:454:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&us_length, socksreq+2, sizeof(short));
./curl-83.40.2/curl/lib/socks_gssapi.c:495:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq, gss_w_token.value, gss_w_token.length);
./curl-83.40.2/curl/lib/socks_gssapi.c:507:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq, gss_recv_token.value, gss_recv_token.length);
./curl-83.40.2/curl/lib/socks_sspi.c:85:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char socksreq[4]; /* room for GSS-API exchange header only */
./curl-83.40.2/curl/lib/socks_sspi.c:101:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(service_name, service, strlen(service));
./curl-83.40.2/curl/lib/socks_sspi.c:198:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(socksreq+2, &us_length, sizeof(short));
./curl-83.40.2/curl/lib/socks_sspi.c:282:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&us_length, socksreq+2, sizeof(short));
./curl-83.40.2/curl/lib/socks_sspi.c:376:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq+2, &us_length, sizeof(short));
./curl-83.40.2/curl/lib/socks_sspi.c:405:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(sspi_w_token[1].pvBuffer, &gss_enc, 1);
./curl-83.40.2/curl/lib/socks_sspi.c:439:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(sspi_send_token.pvBuffer, sspi_w_token[0].pvBuffer,
./curl-83.40.2/curl/lib/socks_sspi.c:441:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy((PUCHAR) sspi_send_token.pvBuffer +(int)sspi_w_token[0].cbBuffer,
./curl-83.40.2/curl/lib/socks_sspi.c:443:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy((PUCHAR) sspi_send_token.pvBuffer
./curl-83.40.2/curl/lib/socks_sspi.c:459:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq+2, &us_length, sizeof(short));
./curl-83.40.2/curl/lib/socks_sspi.c:472:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq, &gss_enc, 1);
./curl-83.40.2/curl/lib/socks_sspi.c:516:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&us_length, socksreq+2, sizeof(short));
./curl-83.40.2/curl/lib/socks_sspi.c:526:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  result = Curl_blockread_all(conn, sock, (char *)sspi_w_token[0].pvBuffer,
./curl-83.40.2/curl/lib/socks_sspi.c:570:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq, sspi_w_token[1].pvBuffer, sspi_w_token[1].cbBuffer);
./curl-83.40.2/curl/lib/socks_sspi.c:582:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(socksreq, sspi_w_token[0].pvBuffer, sspi_w_token[0].cbBuffer);
./curl-83.40.2/curl/lib/ssh.c:426:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(real_path, working_path+3, 4 + working_path_len-3);
./curl-83.40.2/curl/lib/ssh.c:428:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(real_path, working_path, 1 + working_path_len);
./curl-83.40.2/curl/lib/ssh.c:440:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(real_path, homedir, homelen);
./curl-83.40.2/curl/lib/ssh.c:444:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
        memcpy(real_path+homelen+1, working_path + 3,
./curl-83.40.2/curl/lib/ssh.c:454:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(real_path, working_path, 1+working_path_len);
./curl-83.40.2/curl/lib/ssh.c:653:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char md5buffer[33];
./curl-83.40.2/curl/lib/ssh.c:1125:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char tempHome[PATH_MAX];
./curl-83.40.2/curl/lib/ssh.c:1949:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(sshc->readdir_line, sshc->readdir_longentry,
./curl-83.40.2/curl/lib/ssh.c:3264:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(*path, cp, end - cp);
./curl-83.40.2/curl/lib/strdup.c:47:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(newstr, str, (len+1)*sizeof(char));
./curl-83.40.2/curl/lib/strdup.c:70:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(buffer, src, length);
./curl-83.40.2/curl/lib/strerror.c:639:  [2] (buffer) wchar_t:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    wchar_t wbuf[256];
./curl-83.40.2/curl/lib/strerror.c:677:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buffer[256];
./curl-83.40.2/curl/lib/strerror.c:690:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buffer[256];
./curl-83.40.2/curl/lib/strerror.c:803:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char txtbuf[80];
./curl-83.40.2/curl/lib/strerror.c:804:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char msgbuf[sizeof(conn->syserr_buf)];
./curl-83.40.2/curl/lib/strerror.c:1084:  [2] (buffer) wchar_t:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      wchar_t wbuf[256];
./curl-83.40.2/curl/lib/telnet.c:160:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char subopt_ttype[32];             /* Set with suboption TTYPE */
./curl-83.40.2/curl/lib/telnet.c:161:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char subopt_xdisploc[128];         /* Set with suboption XDISPLOC */
./curl-83.40.2/curl/lib/telnet.c:167:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char subbuffer[SUBBUFSIZE];
./curl-83.40.2/curl/lib/telnet.c:346:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
   unsigned char buf[3];
./curl-83.40.2/curl/lib/telnet.c:822:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char option_keyword[128] = "";
./curl-83.40.2/curl/lib/telnet.c:823:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char option_arg[256] = "";
./curl-83.40.2/curl/lib/telnet.c:890:  [2] (integer) atoi:
  Unless checked, the resulting number can exceed the expected range. 
  If source untrusted, check both minimum and maximum, even if the input
  had no minus sign (large numbers can roll over into negative number;
  consider saving to an unsigned value if that is intended). 
        binary_option=atoi(option_arg);
./curl-83.40.2/curl/lib/telnet.c:927:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char temp[2048];
./curl-83.40.2/curl/lib/telnet.c:932:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char varname[128] = "";
./curl-83.40.2/curl/lib/telnet.c:933:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char varval[128] = "";
./curl-83.40.2/curl/lib/telnet.c:1227:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char outbuf[2];
./curl-83.40.2/curl/lib/tftp.c:452:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[64];
./curl-83.40.2/curl/lib/tftp.c:1094:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&state->remote_addr, &fromaddr, fromlen);
./curl-83.40.2/curl/lib/transfer.c:170:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char hexbuffer[11];
./curl-83.40.2/curl/lib/transfer.c:196:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(data->req.upload_fromhere, hexbuffer, hexlen);
./curl-83.40.2/curl/lib/transfer.c:199:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(data->req.upload_fromhere + nread,
./curl-83.40.2/curl/lib/transfer.c:336:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buf[512 + 1];
./curl-83.40.2/curl/lib/transfer.c:341:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(buf, conn->master_buffer + conn->read_pos, show);
./curl-83.40.2/curl/lib/transfer.c:1450:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char prot[16]; /* URL protocol string storage */
./curl-83.40.2/curl/lib/transfer.c:1597:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(newest, url_clone, urllen);
./curl-83.40.2/curl/lib/url.c:1030:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
            memcpy(p, argptr, (size_t)data->set.postfieldsize);
./curl-83.40.2/curl/lib/url.c:3929:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char protobuf[16] = "";
./curl-83.40.2/curl/lib/url.c:4087:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(path+1, query, hostlen);
./curl-83.40.2/curl/lib/url.c:4152:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(reurl, data->change.url, prefixlen);
./curl-83.40.2/curl/lib/url.c:4155:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&reurl[prefixlen], path, plen + 1);
./curl-83.40.2/curl/lib/url.c:4200:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
        char ifname[IFNAMSIZ + 2];
./curl-83.40.2/curl/lib/url.c:4458:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char proxy_env[128];
./curl-83.40.2/curl/lib/url.c:4475:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
    strcpy(envp, "_proxy");
./curl-83.40.2/curl/lib/url.c:4674:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char proxyuser[MAX_CURL_USER_LENGTH]="";
./curl-83.40.2/curl/lib/url.c:4675:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char proxypasswd[MAX_CURL_PASSWORD_LENGTH]="";
./curl-83.40.2/curl/lib/url.c:4915:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(ubuf, login, ulen);
./curl-83.40.2/curl/lib/url.c:4923:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(pbuf, psep + 1, plen);
./curl-83.40.2/curl/lib/url.c:4931:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(obuf, osep + 1, olen);
./curl-83.40.2/curl/lib/url.c:5001:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char type[12]="";
./curl-83.40.2/curl/lib/urldata.h:443:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char nonce[8];
./curl-83.40.2/curl/lib/urldata.h:862:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char ip_addr_str[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/urldata.h:881:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char primary_ip[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/urldata.h:888:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char local_ip[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/urldata.h:1009:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char syserr_buf [256]; /* buffer for Curl_strerror() */
./curl-83.40.2/curl/lib/urldata.h:1095:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char conn_primary_ip[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/urldata.h:1098:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char conn_local_ip[MAX_IPADR_LEN];
./curl-83.40.2/curl/lib/urldata.h:1214:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[BUFSIZE+1]; /* download buffer */
./curl-83.40.2/curl/lib/urldata.h:1215:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char uploadbuffer[BUFSIZE+1]; /* upload buffer */
./curl-83.40.2/curl/lib/urldata.h:1592:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char *str[STRING_LAST]; /* array of strings, pointing to allocated memory */
./curl-83.40.2/curl/lib/version.c:65:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char version[200];
./curl-83.40.2/curl/lib/version.c:131:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char suff[2];
./curl-83.40.2/curl/lib/version.c:315:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char ssh_buffer[80];
./curl-83.40.2/curl/lib/version.c:319:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char ssl_buffer[80];
./curl-83.40.2/curl/lib/vtls/axtls.c:621:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(buf, read_buf,
./curl-83.40.2/curl/lib/vtls/cyassl.c:102:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error_buffer[CYASSL_MAX_ERROR_SZ];
./curl-83.40.2/curl/lib/vtls/cyassl.c:347:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char error_buffer[CYASSL_MAX_ERROR_SZ];
./curl-83.40.2/curl/lib/vtls/cyassl.c:497:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error_buffer[CYASSL_MAX_ERROR_SZ];
./curl-83.40.2/curl/lib/vtls/cyassl.c:542:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error_buffer[CYASSL_MAX_ERROR_SZ];
./curl-83.40.2/curl/lib/vtls/darwinssl.c:804:  [2] (integer) atoi:
  Unless checked, the resulting number can exceed the expected range. 
  If source untrusted, check both minimum and maximum, even if the input
  had no minus sign (large numbers can roll over into negative number;
  consider saving to an unsigned value if that is intended). 
  *major = atoi(os_version_major);
./curl-83.40.2/curl/lib/vtls/darwinssl.c:805:  [2] (integer) atoi:
  Unless checked, the resulting number can exceed the expected range. 
  If source untrusted, check both minimum and maximum, even if the input
  had no minus sign (large numbers can roll over into negative number;
  consider saving to an unsigned value if that is intended). 
  *minor = atoi(os_version_minor);
./curl-83.40.2/curl/lib/vtls/darwinssl.c:1224:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
        char cert_summary_c[128];
./curl-83.40.2/curl/lib/vtls/darwinssl.c:1579:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char buf[cap], *data;
./curl-83.40.2/curl/lib/vtls/darwinssl.c:1581:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fd = open(file, 0);
./curl-83.40.2/curl/lib/vtls/darwinssl.c:1612:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(data + len, buf, n);
./curl-83.40.2/curl/lib/vtls/darwinssl.c:1673:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char subject_cbuf[128];
./curl-83.40.2/curl/lib/vtls/darwinssl.c:1960:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char server_cert_summary_c[128];
./curl-83.40.2/curl/lib/vtls/darwinssl.c:2240:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[120];
./curl-83.40.2/curl/lib/vtls/gskit.c:994:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[120];
./curl-83.40.2/curl/lib/vtls/gtls.c:234:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  if(!(f = fopen(file, "rb")))
./curl-83.40.2/curl/lib/vtls/gtls.c:794:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char certbuf[256] = ""; /* big enough? */
./curl-83.40.2/curl/lib/vtls/gtls.c:858:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      const char *beg = (const char *) chainp[i].data;
./curl-83.40.2/curl/lib/vtls/gtls.c:1054:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char addrbuf[sizeof(struct use_addr)];
./curl-83.40.2/curl/lib/vtls/gtls.c:1055:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char certaddr[sizeof(struct use_addr)];
./curl-83.40.2/curl/lib/vtls/gtls.c:1391:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[120];
./curl-83.40.2/curl/lib/vtls/gtls.c:1555:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(md5sum, gcry_md_read (MD5pw, 0), md5len);
./curl-83.40.2/curl/lib/vtls/nss.c:689:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char buf[50];
./curl-83.40.2/curl/lib/vtls/nss.c:793:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char timeString[256];
./curl-83.40.2/curl/lib/vtls/nss.c:1214:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&nspr_io_methods, PR_GetDefaultIOMethods(), sizeof nspr_io_methods);
./curl-83.40.2/curl/lib/vtls/nss.c:1774:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char protocols[128];
./curl-83.40.2/curl/lib/vtls/nss.c:1779:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&protocols[cur], NGHTTP2_PROTO_VERSION_ID,
./curl-83.40.2/curl/lib/vtls/nss.c:1785:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);
./curl-83.40.2/curl/lib/vtls/openssl.c:155:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(buf, global_passwd, klen+1);
./curl-83.40.2/curl/lib/vtls/openssl.c:234:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char randb[64];
./curl-83.40.2/curl/lib/vtls/openssl.c:450:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      f = fopen(cert_file, "rb");
./curl-83.40.2/curl/lib/vtls/openssl.c:666:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(buf, biomem->data, size);
./curl-83.40.2/curl/lib/vtls/openssl.c:808:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buf[256];
./curl-83.40.2/curl/lib/vtls/openssl.c:898:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[120]; /* We will use this for the OpenSSL error buffer, so it has
./curl-83.40.2/curl/lib/vtls/openssl.c:1210:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
              memcpy(peer_CN, ASN1_STRING_data(tmp), j);
./curl-83.40.2/curl/lib/vtls/openssl.c:1485:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char ssl_buf[1024];
./curl-83.40.2/curl/lib/vtls/openssl.c:1486:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char unknown[32];
./curl-83.40.2/curl/lib/vtls/openssl.c:1890:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char protocols[128];
./curl-83.40.2/curl/lib/vtls/openssl.c:1896:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(&protocols[cur], NGHTTP2_PROTO_VERSION_ID,
./curl-83.40.2/curl/lib/vtls/openssl.c:1904:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);
./curl-83.40.2/curl/lib/vtls/openssl.c:2133:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char error_buffer[256]; /* OpenSSL documents that this must be at least
./curl-83.40.2/curl/lib/vtls/openssl.c:2261:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char namebuf[32];
./curl-83.40.2/curl/lib/vtls/openssl.c:2307:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buf[512];
./curl-83.40.2/curl/lib/vtls/openssl.c:2309:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char namebuf[128];
./curl-83.40.2/curl/lib/vtls/openssl.c:2357:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[1024];
./curl-83.40.2/curl/lib/vtls/openssl.c:2683:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      fp = fopen(data->set.str[STRING_SSL_ISSUERCERT], FOPEN_READTEXT);
./curl-83.40.2/curl/lib/vtls/openssl.c:2983:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error_buffer[120]; /* OpenSSL documents that this must be at least 120
./curl-83.40.2/curl/lib/vtls/openssl.c:3034:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char error_buffer[120]; /* OpenSSL documents that this must be at
./curl-83.40.2/curl/lib/vtls/openssl.c:3089:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char sub[3];
./curl-83.40.2/curl/lib/vtls/openssl.c:3136:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char sub[2];
./curl-83.40.2/curl/lib/vtls/polarssl.c:145:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char errorbuf[128];
./curl-83.40.2/curl/lib/vtls/polarssl.c:332:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&connssl->ssn, old_session, old_session_size);
./curl-83.40.2/curl/lib/vtls/polarssl.c:393:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[1024];
./curl-83.40.2/curl/lib/vtls/polarssl.c:395:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char errorbuf[128];
./curl-83.40.2/curl/lib/vtls/polarssl.c:512:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(new_session, our_ssl_sessionid, sizeof(ssl_session));
./curl-83.40.2/curl/lib/vtls/schannel.c:395:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(inbuf[0].pvBuffer, connssl->encdata_buffer,
./curl-83.40.2/curl/lib/vtls/schannel.c:752:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(outbuf[1].pvBuffer, buf, len);
./curl-83.40.2/curl/lib/vtls/schannel.c:1007:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(connssl->decdata_buffer + connssl->decdata_offset,
./curl-83.40.2/curl/lib/vtls/schannel.c:1134:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buf, connssl->decdata_buffer, size);
./curl-83.40.2/curl/lib/vtls/schannel.c:1420:  [2] (buffer) TCHAR:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      TCHAR cert_hostname_buff[128];
./curl-83.40.2/curl/lib/vtls/vtls.c:197:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy((char *)&randseed, force_entropy, min);
./curl-83.40.2/curl/lib/vtls/vtls.c:216:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    int fd = open(RANDOM_FILE, O_RDONLY);
./curl-83.40.2/curl/lib/vtls/vtls.c:669:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(&output[labellen+1], value, valuelen);
./curl-83.40.2/curl/lib/vtls/vtls.c:783:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fp = fopen(pinnedpubkey, "rb");
./curl-83.40.2/curl/lib/x509asn1.c:292:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(buf, from, outlength);
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:58:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
makeOS400IconvCode(char buf[ICONV_ID_SIZE], unsigned int ccsid)
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:84:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char fromcode[ICONV_ID_SIZE];
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:85:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char tocode[ICONV_ID_SIZE];
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:133:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(d, s, i);
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:470:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy((char *) id, (char *) p, sizeof *p);
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:476:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(cp, (char *) p->protocols, i);
./curl-83.40.2/curl/packages/OS400/ccsidcurl.c:726:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
          free((char *) forms[nargs].value);
./curl-83.40.2/curl/packages/OS400/os400sys.c:769:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(buf->value, t, i);
./curl-83.40.2/curl/packages/OS400/os400sys.c:789:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy((char *) &in, (char *) in_name, sizeof in);
./curl-83.40.2/curl/packages/OS400/os400sys.c:1219:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy((char *) dstaddr, (char *) srcaddr, srclen);
./curl-83.40.2/curl/packages/OS400/os400sys.c:1333:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy((char *) fromaddr, (char *) &laddr, laddrlen);
./curl-83.40.2/curl/packages/vms/curl_crtl_init.c:180:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char unix_shell_name[255];
./curl-83.40.2/curl/src/tool_cb_dbg.c:53:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char timebuf[20];
./curl-83.40.2/curl/src/tool_cb_dbg.c:82:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      config->trace_stream = fopen(config->trace_dump, FOPEN_WRITETEXT);
./curl-83.40.2/curl/src/tool_cb_hdr.c:147:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(copy, ptr, len);
./curl-83.40.2/curl/src/tool_cb_hdr.c:212:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buffer[512]; /* suitably large */
./curl-83.40.2/curl/src/tool_cb_prg.c:47:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char line[MAX_BARLENGTH+1];
./curl-83.40.2/curl/src/tool_cb_prg.c:48:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char format[40];
./curl-83.40.2/curl/src/tool_cb_wrt.c:47:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    file = fopen(outs->filename, "rb");
./curl-83.40.2/curl/src/tool_cb_wrt.c:57:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  file = fopen(outs->filename, "wb");
./curl-83.40.2/curl/src/tool_doswin.c:103:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char new_name[PATH_MAX];
./curl-83.40.2/curl/src/tool_doswin.c:123:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char dos_name[PATH_MAX];
./curl-83.40.2/curl/src/tool_doswin.c:184:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy (d, "plus", 4);
./curl-83.40.2/curl/src/tool_doswin.c:214:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char fname[PATH_MAX];
./curl-83.40.2/curl/src/tool_easysrc.c:179:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      out = fopen(o, FOPEN_WRITETEXT);
./curl-83.40.2/curl/src/tool_formparse.c:151:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char name[256];
./curl-83.40.2/curl/src/tool_formparse.c:153:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char type_major[128] = "";
./curl-83.40.2/curl/src/tool_formparse.c:154:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char type_minor[128] = "";
./curl-83.40.2/curl/src/tool_getparam.c:684:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
          FILE *newfile = fopen(nextarg, FOPEN_WRITETEXT);
./curl-83.40.2/curl/src/tool_getparam.c:1142:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
            file = fopen(p, "rb");
./curl-83.40.2/curl/src/tool_getparam.c:1208:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
          file = fopen(nextarg, "rb");
./curl-83.40.2/curl/src/tool_getparam.c:1264:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
        memcpy(config->postfields, oldpost, (size_t)oldlen);
./curl-83.40.2/curl/src/tool_getparam.c:1267:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
        memcpy(&config->postfields[oldlen+1], postdata, size);
./curl-83.40.2/curl/src/tool_getparam.c:1617:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
        char buffer[32];
./curl-83.40.2/curl/src/tool_getparam.c:1751:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
          file = fopen(nextarg, FOPEN_READTEXT);
./curl-83.40.2/curl/src/tool_getpass.c:230:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  int fd = open("/dev/tty", O_RDONLY);
./curl-83.40.2/curl/src/tool_homedir.c:36:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char  buf1[1024], buf2[1024];
./curl-83.40.2/curl/src/tool_main.c:100:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char fname[CURL_MT_LOGFNAME_BUFSIZE];
./curl-83.40.2/curl/src/tool_metalink.c:136:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:154:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA1_Final(unsigned char digest[20], SHA_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:172:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA256_Final(unsigned char digest[32], SHA256_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:192:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:194:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(digest, gcry_md_read(*ctx, 0), 16);
./curl-83.40.2/curl/src/tool_metalink.c:211:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA1_Final(unsigned char digest[20], SHA_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:213:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(digest, gcry_md_read(*ctx, 0), 20);
./curl-83.40.2/curl/src/tool_metalink.c:230:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA256_Final(unsigned char digest[32], SHA256_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:232:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(digest, gcry_md_read(*ctx, 0), 32);
./curl-83.40.2/curl/src/tool_metalink.c:284:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *pctx)
./curl-83.40.2/curl/src/tool_metalink.c:301:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA1_Final(unsigned char digest[20], SHA_CTX *pctx)
./curl-83.40.2/curl/src/tool_metalink.c:318:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA256_Final(unsigned char digest[32], SHA256_CTX *pctx)
./curl-83.40.2/curl/src/tool_metalink.c:338:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:356:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA1_Final(unsigned char digest[20], SHA_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:374:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA256_Final(unsigned char digest[32], SHA256_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:411:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void MD5_Final(unsigned char digest[16], MD5_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:432:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA1_Final(unsigned char digest[20], SHA_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:453:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static void SHA256_Final(unsigned char digest[32], SHA256_CTX *ctx)
./curl-83.40.2/curl/src/tool_metalink.c:608:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fd = open(filename, flags);
./curl-83.40.2/curl/src/tool_metalink.c:629:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    unsigned char buf[4096];
./curl-83.40.2/curl/src/tool_msgs.c:47:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char print_buffer[256];
./curl-83.40.2/curl/src/tool_operate.c:149:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[8192];
./curl-83.40.2/curl/src/tool_operate.c:154:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  file = fopen(name, "r"); /* VMS */
./curl-83.40.2/curl/src/tool_operate.c:193:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char errorbuffer[CURL_ERROR_SIZE];
./curl-83.40.2/curl/src/tool_operate.c:321:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      FILE *newfile = fopen(config->headerfile, "wb");
./curl-83.40.2/curl/src/tool_operate.c:609:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
            FILE *file = fopen(outfile, config->resume_from?"ab":"wb",
./curl-83.40.2/curl/src/tool_operate.c:613:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
            FILE *file = fopen(outfile, config->resume_from?"ab":"wb");
./curl-83.40.2/curl/src/tool_operate.c:665:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
              infd = open(uploadfile, O_RDONLY | O_BINARY);
./curl-83.40.2/curl/src/tool_operate.c:668:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
              infd = open(uploadfile, O_RDONLY | O_BINARY,
./curl-83.40.2/curl/src/tool_operate.c:674:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
          infd = open(uploadfile, O_RDONLY | O_BINARY);
./curl-83.40.2/curl/src/tool_operhlp.c:162:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char buffer[512]; /* suitably large */
./curl-83.40.2/curl/src/tool_paramhlp.c:61:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[256];
./curl-83.40.2/curl/src/tool_paramhlp.c:390:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char passwd[256] = "";
./curl-83.40.2/curl/src/tool_paramhlp.c:391:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char prompt[256];
./curl-83.40.2/curl/src/tool_paramhlp.c:426:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&passptr[userlen+1], passwd, passwdlen+1);
./curl-83.40.2/curl/src/tool_parsecfg.c:51:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char filebuffer[512];
./curl-83.40.2/curl/src/tool_parsecfg.c:72:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
        file = fopen(filebuffer, FOPEN_READTEXT);
./curl-83.40.2/curl/src/tool_parsecfg.c:118:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    file = fopen(filename, FOPEN_READTEXT);
./curl-83.40.2/curl/src/tool_parsecfg.c:334:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[4096];
./curl-83.40.2/curl/src/tool_setopt.c:204:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(e, "\\n");
./curl-83.40.2/curl/src/tool_setopt.c:208:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(e, "\\r");
./curl-83.40.2/curl/src/tool_setopt.c:212:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(e, "\\t");
./curl-83.40.2/curl/src/tool_setopt.c:216:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(e, "\\\\");
./curl-83.40.2/curl/src/tool_setopt.c:220:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(e, "\\\"");
./curl-83.40.2/curl/src/tool_setopt.c:281:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char preamble[80];          /* should accommodate any symbol name */
./curl-83.40.2/curl/src/tool_setopt.c:324:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char preamble[80];
./curl-83.40.2/curl/src/tool_setopt.c:473:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[256];
./curl-83.40.2/curl/src/tool_strdup.c:42:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(newstr, str, (len+1)*sizeof(char));
./curl-83.40.2/curl/src/tool_urlglob.c:54:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(pat->content.Set.elements[0], fixed, len);
./curl-83.40.2/curl/src/tool_urlglob.c:352:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
          memcpy(buf, pattern, skip);
./curl-83.40.2/curl/src/tool_urlglob.c:440:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
      char text[128];
./curl-83.40.2/curl/src/tool_urlglob.c:578:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char numbuf[18];
./curl-83.40.2/curl/src/tool_urlglob.c:665:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(&target[stringlen], appendthis, appendlen);
./curl-83.40.2/curl/src/tool_writeenv.c:76:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char *string, numtext[10];
./curl-83.40.2/curl/tests/libtest/chkhostname.c:30:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buff[HOSTNAME_MAX];
./curl-83.40.2/curl/tests/libtest/first.c:90:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char fname[CURL_MT_LOGFNAME_BUFSIZE];
./curl-83.40.2/curl/tests/libtest/first.c:117:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char dump[200*3+1];
./curl-83.40.2/curl/tests/libtest/lib1502.c:49:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char redirect[160];
./curl-83.40.2/curl/tests/libtest/lib1506.c:39:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char target_url[256];
./curl-83.40.2/curl/tests/libtest/lib1506.c:40:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char dnsentry[256];
./curl-83.40.2/curl/tests/libtest/lib1510.c:37:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char target_url[256];
./curl-83.40.2/curl/tests/libtest/lib1510.c:38:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char dnsentry[256];
./curl-83.40.2/curl/tests/libtest/lib1512.c:41:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char dnsentry[256];
./curl-83.40.2/curl/tests/libtest/lib1512.c:44:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char target_url[256];
./curl-83.40.2/curl/tests/libtest/lib1515.c:120:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char dns_entry[256];
./curl-83.40.2/curl/tests/libtest/lib1515.c:132:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char target_url[256];
./curl-83.40.2/curl/tests/libtest/lib1520.c:63:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/tests/libtest/lib1525.c:42:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr, data, strlen(data));
./curl-83.40.2/curl/tests/libtest/lib1526.c:41:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr, data, strlen(data));
./curl-83.40.2/curl/tests/libtest/lib1527.c:41:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr, data, strlen(data));
./curl-83.40.2/curl/tests/libtest/lib1529.c:31:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char bURL[512];
./curl-83.40.2/curl/tests/libtest/lib1900.c:33:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
char *urlstring[MAX_URLS];
./curl-83.40.2/curl/tests/libtest/lib1900.c:35:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
char *site_blacklist[MAX_BLACKLIST];
./curl-83.40.2/curl/tests/libtest/lib1900.c:36:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
char *server_blacklist[MAX_BLACKLIST];
./curl-83.40.2/curl/tests/libtest/lib1900.c:55:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[200];
./curl-83.40.2/curl/tests/libtest/lib1900.c:61:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  f = fopen(filename, "rb");
./curl-83.40.2/curl/tests/libtest/lib1900.c:114:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char urlbuf[256];
./curl-83.40.2/curl/tests/libtest/lib500.c:96:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      FILE *moo = fopen(libtest_arg2, "wb");
./curl-83.40.2/curl/tests/libtest/lib505.c:56:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd_src = fopen(libtest_arg2, "rb");
./curl-83.40.2/curl/tests/libtest/lib510.c:51:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/tests/libtest/lib518.c:55:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static char msgbuff[256];
./curl-83.40.2/curl/tests/libtest/lib518.c:86:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    fpa[i] = fopen(DEV_NULL, "r");
./curl-83.40.2/curl/tests/libtest/lib518.c:107:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char strbuff[256];
./curl-83.40.2/curl/tests/libtest/lib518.c:108:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char strbuff1[81];
./curl-83.40.2/curl/tests/libtest/lib518.c:109:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char strbuff2[81];
./curl-83.40.2/curl/tests/libtest/lib518.c:133:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
    strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib518.c:141:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
    strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib518.c:199:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib518.c:207:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib518.c:325:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fd[0] = open(DEV_NULL, O_RDONLY);
./curl-83.40.2/curl/tests/libtest/lib518.c:398:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
    sprintf(strbuff, "select limit is FD_SETSIZE %d", FD_SETSIZE);
./curl-83.40.2/curl/tests/libtest/lib518.c:412:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(strbuff, "select limit is FD_SETSIZE %d", FD_SETSIZE);
./curl-83.40.2/curl/tests/libtest/lib518.c:437:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
    sprintf(strbuff, "stdio fopen() fails with lots of fds open()");
./curl-83.40.2/curl/tests/libtest/lib525.c:56:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd_src = fopen(libtest_arg2, "rb");
./curl-83.40.2/curl/tests/libtest/lib530.c:39:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char target_url[256];
./curl-83.40.2/curl/tests/libtest/lib537.c:56:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static char msgbuff[256];
./curl-83.40.2/curl/tests/libtest/lib537.c:87:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    fpa[i] = fopen(DEV_NULL, "r");
./curl-83.40.2/curl/tests/libtest/lib537.c:109:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char strbuff[256];
./curl-83.40.2/curl/tests/libtest/lib537.c:110:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char strbuff1[81];
./curl-83.40.2/curl/tests/libtest/lib537.c:134:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
    strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib537.c:142:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
    strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib537.c:194:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib537.c:202:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
      strcpy(strbuff, "INFINITY");
./curl-83.40.2/curl/tests/libtest/lib537.c:319:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  fd[0] = open(DEV_NULL, O_RDONLY);
./curl-83.40.2/curl/tests/libtest/lib537.c:401:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
    sprintf(strbuff, "select limit is FD_SETSIZE %d", FD_SETSIZE);
./curl-83.40.2/curl/tests/libtest/lib537.c:415:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(strbuff, "select limit is FD_SETSIZE %d", FD_SETSIZE);
./curl-83.40.2/curl/tests/libtest/lib537.c:440:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
    sprintf(strbuff, "stdio fopen() fails with lots of fds open()");
./curl-83.40.2/curl/tests/libtest/lib539.c:67:  [2] (buffer) strcat:
  Does not check for buffer overflows when concatenating to destination.
  Consider using strncat or strlcat (warning, strncat is easily misused).
  Risk is low because the source is a constant string.
   newURL = strcat(strcpy(newURL, URL), "./");
./curl-83.40.2/curl/tests/libtest/lib540.c:191:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[246]; /* naively fixed-size */
./curl-83.40.2/curl/tests/libtest/lib541.c:48:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd_src = fopen(libtest_arg2, "rb");
./curl-83.40.2/curl/tests/libtest/lib544.c:69:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination.
  Consider using strncpy or strlcpy (warning, strncpy is easily misused). Risk
  is low because the source is a constant string.
  strcpy(teststring, "FAIL");
./curl-83.40.2/curl/tests/libtest/lib552.c:124:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static char databuf[70000]; /* MUST be more than 64k OR MAX_INITIAL_POST_SIZE */
./curl-83.40.2/curl/tests/libtest/lib552.c:132:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr, databuf + current_offset, given);
./curl-83.40.2/curl/tests/libtest/lib553.c:36:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char buf[1024];
./curl-83.40.2/curl/tests/libtest/lib553.c:48:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(ptr, buf, size);
./curl-83.40.2/curl/tests/libtest/lib553.c:56:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static char buf[SIZE_HEADERS + 100];
./curl-83.40.2/curl/tests/libtest/lib553.c:77:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
    int len = sprintf(buf, "Header%d: ", i);
./curl-83.40.2/curl/tests/libtest/lib556.c:73:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char buf[1024];
./curl-83.40.2/curl/tests/libtest/lib557.c:61:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib557.c:68:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib557.c:75:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib557.c:82:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib557.c:89:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib557.c:96:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib557.c:103:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char result[BUFSZ];   /* result string   */
./curl-83.40.2/curl/tests/libtest/lib566.c:53:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    moo = fopen(libtest_arg2, "wb");
./curl-83.40.2/curl/tests/libtest/lib568.c:77:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  sdp = open("log/file568.txt", O_RDONLY);
./curl-83.40.2/curl/tests/libtest/lib568.c:81:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  sdpf = fopen("log/file568.txt", "rb");
./curl-83.40.2/curl/tests/libtest/lib569.c:44:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  idfile = fopen(libtest_arg2, "wb");
./curl-83.40.2/curl/tests/libtest/lib571.c:107:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  protofile = fopen(libtest_arg2, "wb");
./curl-83.40.2/curl/tests/libtest/lib572.c:95:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  params = open("log/file572.txt", O_RDONLY);
./curl-83.40.2/curl/tests/libtest/lib572.c:99:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  paramsf = fopen("log/file572.txt", "rb");
./curl-83.40.2/curl/tests/libtest/lib578.c:33:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  FILE *moo = fopen(libtest_arg2, "wb");
./curl-83.40.2/curl/tests/libtest/lib579.c:56:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    moo = fopen(libtest_arg2, "ab");
./curl-83.40.2/curl/tests/libtest/lib579.c:80:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(ptr, data, len);
./curl-83.40.2/curl/tests/libtest/lib582.c:245:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  hd_src = fopen(libtest_arg2, "rb");
./curl-83.40.2/curl/tests/libtest/lib591.c:51:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  upload = fopen(libtest_arg3, "rb");
./curl-83.40.2/curl/tests/libtest/lib599.c:82:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    moo = fopen(libtest_arg2, "wb");
./curl-83.40.2/curl/tests/libtest/libntlmconnect.c:56:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(output, ptr, size * nmemb);
./curl-83.40.2/curl/tests/libtest/testtrace.c:92:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char timebuf[20];
./curl-83.40.2/curl/tests/server/fake_ntlm.c:113:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[1024];
./curl-83.40.2/curl/tests/server/fake_ntlm.c:185:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/fake_ntlm.c:203:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/fake_ntlm.c:223:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/fake_ntlm.c:244:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/getpart.c:183:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(*dst_buf + *dst_len, src_buf, src_len);
./curl-83.40.2/curl/tests/server/getpart.c:218:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(*buf, buf64, src_len);
./curl-83.40.2/curl/tests/server/getpart.c:253:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char couter[MAX_TAG_LEN+1]; /* current outermost section */
./curl-83.40.2/curl/tests/server/getpart.c:254:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char cmain[MAX_TAG_LEN+1];  /* current main section */
./curl-83.40.2/curl/tests/server/getpart.c:255:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char csub[MAX_TAG_LEN+1];   /* current sub section */
./curl-83.40.2/curl/tests/server/getpart.c:256:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char ptag[MAX_TAG_LEN+1];   /* potential tag */
./curl-83.40.2/curl/tests/server/getpart.c:257:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char patt[MAX_TAG_LEN+1];   /* potential attributes */
./curl-83.40.2/curl/tests/server/getpart.c:316:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(ptag, ptr, len.uns);
./curl-83.40.2/curl/tests/server/getpart.c:377:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(ptag, ptr, len.uns);
./curl-83.40.2/curl/tests/server/getpart.c:396:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
      memcpy(patt, ptr, len.uns);
./curl-83.40.2/curl/tests/server/rtspd.c:95:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
./curl-83.40.2/curl/tests/server/rtspd.c:100:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  bool open;      /* keep connection open info, as found in the request */
./curl-83.40.2/curl/tests/server/rtspd.c:331:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char request[REQUEST_KEYWORD_SIZE];
./curl-83.40.2/curl/tests/server/rtspd.c:332:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char doc[MAXDOCNAMELEN];
./curl-83.40.2/curl/tests/server/rtspd.c:333:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char prot_str[5];
./curl-83.40.2/curl/tests/server/rtspd.c:334:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char logbuf[256];
./curl-83.40.2/curl/tests/server/rtspd.c:412:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(logbuf, "Requested test number %ld part %ld",
./curl-83.40.2/curl/tests/server/rtspd.c:418:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/rtspd.c:498:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
                  memcpy(rtp_scratch + 4 + i, RTP_DATA, RTP_DATA_SIZE);
./curl-83.40.2/curl/tests/server/rtspd.c:506:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
                  memcpy(req->rtp_buffer + req->rtp_buffersize, rtp_scratch, rtp_size + 4);
./curl-83.40.2/curl/tests/server/rtspd.c:676:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
     req->open &&
./curl-83.40.2/curl/tests/server/rtspd.c:732:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    dump = fopen(REQUEST_DUMP, "ab");
./curl-83.40.2/curl/tests/server/rtspd.c:898:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char weare[256];
./curl-83.40.2/curl/tests/server/rtspd.c:900:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char partbuf[80]="data";
./curl-83.40.2/curl/tests/server/rtspd.c:930:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char msgbuf[64];
./curl-83.40.2/curl/tests/server/rtspd.c:940:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(msgbuf, "RTSP_SERVER WE ROOLZ: %ld\r\n", (long)getpid());
./curl-83.40.2/curl/tests/server/rtspd.c:974:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(partbuf, "data%ld", req->partno);
./curl-83.40.2/curl/tests/server/rtspd.c:976:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/rtspd.c:1000:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/rtspd.c:1041:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  dump = fopen(RESPONSE_DUMP, "ab");
./curl-83.40.2/curl/tests/server/rtspd.c:1123:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char command[32];
./curl-83.40.2/curl/tests/server/rtspd.c:1405:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      if(!req.open) {
./curl-83.40.2/curl/tests/server/rtspd.c:1410:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      if(req.open)
./curl-83.40.2/curl/tests/server/rtspd.c:1413:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    } while(req.open || (req.testno == DOCNUMBER_CONNECT));
./curl-83.40.2/curl/tests/server/sockfilt.c:467:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char data[120];
./curl-83.40.2/curl/tests/server/sockfilt.c:476:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(optr, "\\n");
./curl-83.40.2/curl/tests/server/sockfilt.c:481:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(optr, "\\r");
./curl-83.40.2/curl/tests/server/sockfilt.c:486:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(optr, "%c", (ISGRAPH(ptr[i]) || ptr[i]==0x20) ?ptr[i]:'.');
./curl-83.40.2/curl/tests/server/sockfilt.c:903:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char buffer[17010];
./curl-83.40.2/curl/tests/server/sockfilt.c:904:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char data[16];
./curl-83.40.2/curl/tests/server/sws.c:95:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
./curl-83.40.2/curl/tests/server/sws.c:102:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  bool open;      /* keep connection open info, as found in the request */
./curl-83.40.2/curl/tests/server/sws.c:356:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/sws.c:455:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char request[REQUEST_KEYWORD_SIZE];
./curl-83.40.2/curl/tests/server/sws.c:456:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char doc[MAXDOCNAMELEN];
./curl-83.40.2/curl/tests/server/sws.c:457:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char logbuf[456];
./curl-83.40.2/curl/tests/server/sws.c:497:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
        sprintf(logbuf, "Got a *HUGE* request HTTP/%d.%d",
./curl-83.40.2/curl/tests/server/sws.c:530:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
        sprintf(logbuf, "Requested test number %ld part %ld",
./curl-83.40.2/curl/tests/server/sws.c:621:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
        sprintf(logbuf, "Requested test number %ld part %ld (from host name)",
./curl-83.40.2/curl/tests/server/sws.c:671:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(logbuf, "Requested GOPHER test number %ld part %ld",
./curl-83.40.2/curl/tests/server/sws.c:786:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
     req->open &&
./curl-83.40.2/curl/tests/server/sws.c:852:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    dump = fopen(dumpfile, "ab");
./curl-83.40.2/curl/tests/server/sws.c:1041:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char weare[256];
./curl-83.40.2/curl/tests/server/sws.c:1069:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char msgbuf[64];
./curl-83.40.2/curl/tests/server/sws.c:1079:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(msgbuf, "WE ROOLZ: %ld\r\n", (long)getpid());
./curl-83.40.2/curl/tests/server/sws.c:1098:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char partbuf[80];
./curl-83.40.2/curl/tests/server/sws.c:1112:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/sws.c:1135:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/sws.c:1175:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  dump = fopen(responsedump, "ab");
./curl-83.40.2/curl/tests/server/sws.c:1243:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char command[32];
./curl-83.40.2/curl/tests/server/sws.c:1405:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char readclient[2][256];
./curl-83.40.2/curl/tests/server/sws.c:1406:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char readserver[2][256];
./curl-83.40.2/curl/tests/server/sws.c:1905:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  if(!req->open) {
./curl-83.40.2/curl/tests/server/sws.c:1930:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  if(req->open) {
./curl-83.40.2/curl/tests/server/sws.c:1957:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char port_str[11];
./curl-83.40.2/curl/tests/server/sws.c:2302:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
            if(!req.open)
./curl-83.40.2/curl/tests/server/tftp.h:45:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char th_data[1];         /* data or error string */
./curl-83.40.2/curl/tests/server/tftpd.c:128:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char storage[PKTSIZE];
./curl-83.40.2/curl/tests/server/tftpd.c:493:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
    memcpy(dp->th_data, test->rptr, copy_n);
./curl-83.40.2/curl/tests/server/tftpd.c:566:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char outfile[256];
./curl-83.40.2/curl/tests/server/tftpd.c:568:  [2] (misc) open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    test->ofile=open(outfile, O_CREAT|O_RDWR, 0777);
./curl-83.40.2/curl/tests/server/tftpd.c:629:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char rbuf[PKTSIZE];
./curl-83.40.2/curl/tests/server/tftpd.c:956:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  server = fopen(REQUEST_DUMP, "ab");
./curl-83.40.2/curl/tests/server/tftpd.c:1041:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  stream=fopen(filename, "rb");
./curl-83.40.2/curl/tests/server/tftpd.c:1107:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char partbuf[80]="data";
./curl-83.40.2/curl/tests/server/tftpd.c:1112:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char weare[128];
./curl-83.40.2/curl/tests/server/tftpd.c:1113:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
    size_t count = sprintf(weare, "WE ROOLZ: %ld\r\n", (long)getpid());
./curl-83.40.2/curl/tests/server/tftpd.c:1155:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(partbuf, "data%ld", partno);
./curl-83.40.2/curl/tests/server/tftpd.c:1158:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
      FILE *stream=fopen(file, "rb");
./curl-83.40.2/curl/tests/server/tftpd.c:1394:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(tp->th_msg, pe->e_msg, length + 1);
./curl-83.40.2/curl/tests/server/util.c:68:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char buf[256*3];
./curl-83.40.2/curl/tests/server/util.c:80:  [2] (buffer) sprintf:
  Does not check for buffer overflows. Use snprintf or vsnprintf. Risk
  is low because the source has a constant maximum length.
      sprintf(optr, "%%%02x", *iptr++);
./curl-83.40.2/curl/tests/server/util.c:92:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buffer[2048 + 1];
./curl-83.40.2/curl/tests/server/util.c:98:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char timebuf[20];
./curl-83.40.2/curl/tests/server/util.c:122:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  logfp = fopen(serverlogfile, "ab");
./curl-83.40.2/curl/tests/server/util.c:140:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char buf[512];
./curl-83.40.2/curl/tests/server/util.c:189:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  static char filename[256];
./curl-83.40.2/curl/tests/server/util.c:257:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
  pidfile = fopen(filename, "wb");
./curl-83.40.2/curl/tests/server/util.c:275:  [2] (misc) fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move
  things around to create a race condition, control its ancestors, or change
  its contents?. 
    lockfile = fopen(filename, "wb");
./curl-83.40.2/curl/tests/unit/unit1304.c:28:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
static char filename[64];
./curl-83.40.2/curl/tests/unit/unit1304.c:52:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination. Make
  sure destination can always hold the source data. 
  memcpy(filename, filename1, strlen(filename1));
./curl-83.40.2/curl/tests/unit/unit1307.c:34:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char pattern[MAX_PATTERN_L];
./curl-83.40.2/curl/tests/unit/unit1307.c:35:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  char string[MAX_STRING_L];
./curl-83.40.2/curl/tests/unit/unit1395.c:68:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
    char *out = Curl_dedotdotify((char *)pairs[i].input);
./curl-83.40.2/curl/tests/unit/unit1398.c:32:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
char buf[3] = {'b', 'u', 'g'};
./curl-83.40.2/curl/tests/unit/unit1398.c:35:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
char output[24];
./curl-83.40.2/curl/tests/unit/unit1600.c:43:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char output[21];
./curl-83.40.2/curl/tests/unit/unit1601.c:38:  [2] (buffer) char:
  Statically-sized arrays can be overflowed. Perform bounds checking,
  use functions that limit length, or ensure that the size is larger than
  the maximum possible length. 
  unsigned char output[16];

Hits = 1040
Lines analyzed = 176920 in 4.16 seconds (48384 lines/second)
Physical Source Lines of Code (SLOC) = 114203
Hits@level = [0]   0 [1]   0 [2] 795 [3]  42 [4] 203 [5]   0
Hits@level+ = [0+] 1040 [1+] 1040 [2+] 1040 [3+] 245 [4+] 203 [5+]   0
Hits/KSLOC@level+ = [0+] 9.10659 [1+] 9.10659 [2+] 9.10659 [3+] 2.1453 [4+] 1.77754 [5+]   0
Minimum risk level = 2
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
